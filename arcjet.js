"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/arcjet";
exports.ids = ["vendor-chunks/arcjet"];
exports.modules = {

/***/ "(rsc)/./node_modules/arcjet/index.js":
/*!**************************************!*\
  !*** ./node_modules/arcjet/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArcjetAllowDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetAllowDecision),\n/* harmony export */   ArcjetBotReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason),\n/* harmony export */   ArcjetChallengeDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetChallengeDecision),\n/* harmony export */   ArcjetDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDecision),\n/* harmony export */   ArcjetDenyDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision),\n/* harmony export */   ArcjetEdgeRuleReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEdgeRuleReason),\n/* harmony export */   ArcjetEmailReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason),\n/* harmony export */   ArcjetErrorDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision),\n/* harmony export */   ArcjetErrorReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason),\n/* harmony export */   ArcjetFilterReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetFilterReason),\n/* harmony export */   ArcjetIpDetails: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetIpDetails),\n/* harmony export */   ArcjetRateLimitReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason),\n/* harmony export */   ArcjetReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason),\n/* harmony export */   ArcjetRuleResult: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult),\n/* harmony export */   ArcjetSensitiveInfoReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason),\n/* harmony export */   ArcjetShieldReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason),\n/* harmony export */   botCategories: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.botCategories),\n/* harmony export */   \"default\": () => (/* binding */ arcjet),\n/* harmony export */   detectBot: () => (/* binding */ detectBot),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   fixedWindow: () => (/* binding */ fixedWindow),\n/* harmony export */   protectSignup: () => (/* binding */ protectSignup),\n/* harmony export */   sensitiveInfo: () => (/* binding */ sensitiveInfo),\n/* harmony export */   shield: () => (/* binding */ shield),\n/* harmony export */   slidingWindow: () => (/* binding */ slidingWindow),\n/* harmony export */   tokenBucket: () => (/* binding */ tokenBucket),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail)\n/* harmony export */ });\n/* harmony import */ var _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcjet/protocol */ \"(rsc)/./node_modules/@arcjet/protocol/index.js\");\n/* harmony import */ var _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcjet/analyze */ \"(rsc)/./node_modules/@arcjet/analyze/index.js\");\n/* harmony import */ var _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcjet/duration */ \"(rsc)/./node_modules/@arcjet/duration/index.js\");\n/* harmony import */ var _arcjet_headers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcjet/headers */ \"(rsc)/./node_modules/@arcjet/headers/index.js\");\n/* harmony import */ var _arcjet_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcjet/runtime */ \"(rsc)/./node_modules/@arcjet/runtime/index.js\");\n/* harmony import */ var _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcjet/stable-hash */ \"(rsc)/./node_modules/@arcjet/stable-hash/index.js\");\n/* harmony import */ var _arcjet_cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcjet/cache */ \"(rsc)/./node_modules/@arcjet/cache/index.js\");\n\n\n\n\n\n\n\n\n\n\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nfunction errorMessage(err) {\n    if (err) {\n        if (typeof err === \"string\") {\n            return err;\n        }\n        if (typeof err === \"object\" &&\n            \"message\" in err &&\n            typeof err.message === \"string\") {\n            return err.message;\n        }\n    }\n    return \"Unknown problem\";\n}\nconst knownFields = [\n    \"ip\",\n    \"method\",\n    \"protocol\",\n    \"host\",\n    \"path\",\n    \"headers\",\n    \"body\",\n    \"email\",\n    \"cookies\",\n    \"query\",\n];\nfunction isUnknownRequestProperty(key) {\n    return !knownFields.includes(key);\n}\nfunction isEmailType(type) {\n    return (type === \"FREE\" ||\n        type === \"DISPOSABLE\" ||\n        type === \"NO_MX_RECORDS\" ||\n        type === \"NO_GRAVATAR\" ||\n        type === \"INVALID\");\n}\nclass Performance {\n    log;\n    constructor(logger) {\n        this.log = logger;\n    }\n    // TODO(#2020): We should no-op this if loglevel is not `debug` to do less work\n    measure(label) {\n        const start = performance.now();\n        return () => {\n            const end = performance.now();\n            const diff = end - start;\n            this.log.debug(\"LATENCY %s: %sms\", label, diff.toFixed(3));\n        };\n    }\n}\nfunction toString(value) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return `${value}`;\n    }\n    if (typeof value === \"boolean\") {\n        return value ? \"true\" : \"false\";\n    }\n    return \"<unsupported value>\";\n}\n// This is the Symbol that Vercel defines in their infrastructure to access the\n// Context (where available). The Context can contain the `waitUntil` function.\n// https://github.com/vercel/vercel/blob/930d7fb892dc26f240f2b950d963931c45e1e661/packages/functions/src/get-context.ts#L6\nconst SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction lookupWaitUntil() {\n    const fromSymbol = globalThis;\n    if (typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT] === \"object\" &&\n        fromSymbol[SYMBOL_FOR_REQ_CONTEXT] !== null &&\n        \"get\" in fromSymbol[SYMBOL_FOR_REQ_CONTEXT] &&\n        typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get === \"function\") {\n        const vercelCtx = fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get();\n        if (typeof vercelCtx === \"object\" &&\n            vercelCtx !== null &&\n            \"waitUntil\" in vercelCtx &&\n            typeof vercelCtx.waitUntil === \"function\") {\n            return vercelCtx.waitUntil;\n        }\n    }\n}\nfunction toAnalyzeRequest(request) {\n    const headers = {};\n    if (typeof request.headers !== \"undefined\") {\n        for (const [key, value] of request.headers.entries()) {\n            headers[key] = value;\n        }\n    }\n    return {\n        ...request,\n        headers,\n    };\n}\nfunction extraProps(details) {\n    const extra = new Map();\n    for (const [key, value] of Object.entries(details)) {\n        if (isUnknownRequestProperty(key)) {\n            extra.set(key, toString(value));\n        }\n    }\n    return Object.fromEntries(extra.entries());\n}\nfunction createTypeValidator(...types) {\n    return (key, value) => {\n        const typeOfValue = typeof value;\n        if (!types.includes(typeOfValue)) {\n            if (types.length === 1) {\n                throw new Error(`invalid type for \\`${key}\\` - expected ${types[0]}`);\n            }\n            else {\n                throw new Error(`invalid type for \\`${key}\\` - expected one of ${types.join(\", \")}`);\n            }\n        }\n        else {\n            return false;\n        }\n    };\n}\nfunction createValueValidator(\n// This uses types to ensure we have at least 2 values\n...values) {\n    return (key, value) => {\n        // We cast the values to unknown because the optionValue isn't known but\n        // we only want to use `values` on string enumerations\n        if (!values.includes(value)) {\n            throw new Error(`invalid value for \\`${key}\\` - expected one of ${values.map((value) => `'${value}'`).join(\", \")}`);\n        }\n    };\n}\nfunction createArrayValidator(validate) {\n    return (key, value) => {\n        if (Array.isArray(value)) {\n            for (const [idx, item] of value.entries()) {\n                validate(`${key}[${idx}]`, item);\n            }\n        }\n        else {\n            throw new Error(`invalid type for \\`${key}\\` - expected an array`);\n        }\n    };\n}\nfunction createValidator({ rule, validations, }) {\n    return (options) => {\n        for (const { key, validate, required } of validations) {\n            if (required && !Object.hasOwn(options, key)) {\n                throw new Error(`\\`${rule}\\` options error: \\`${key}\\` is required`);\n            }\n            const value = options[key];\n            // The `required` flag is checked above, so these should only be validated\n            // if the value is not undefined.\n            if (typeof value !== \"undefined\") {\n                try {\n                    validate(key, value);\n                }\n                catch (err) {\n                    throw new Error(`\\`${rule}\\` options error: ${errorMessage(err)}`);\n                }\n            }\n        }\n    };\n}\nconst validateString = createTypeValidator(\"string\");\nconst validateNumber = createTypeValidator(\"number\");\nconst validateBoolean = createTypeValidator(\"boolean\");\nconst validateFunction = createTypeValidator(\"function\");\nconst validateStringOrNumber = createTypeValidator(\"string\", \"number\");\nconst validateStringArray = createArrayValidator(validateString);\nconst validateMode = createValueValidator(\"LIVE\", \"DRY_RUN\");\nconst validateEmailTypes = createArrayValidator(createValueValidator(\"DISPOSABLE\", \"FREE\", \"NO_MX_RECORDS\", \"NO_GRAVATAR\", \"INVALID\"));\nconst validateTokenBucketOptions = createValidator({\n    rule: \"tokenBucket\",\n    validations: [\n        {\n            key: \"mode\",\n            required: false,\n            validate: validateMode,\n        },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"refillRate\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n        { key: \"capacity\", required: true, validate: validateNumber },\n    ],\n});\nconst validateFixedWindowOptions = createValidator({\n    rule: \"fixedWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"window\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSlidingWindowOptions = createValidator({\n    rule: \"slidingWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSensitiveInfoOptions = createValidator({\n    rule: \"sensitiveInfo\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n        { key: \"contextWindowSize\", required: false, validate: validateNumber },\n        { key: \"detect\", required: false, validate: validateFunction },\n    ],\n});\nconst validateEmailOptions = createValidator({\n    rule: \"validateEmail\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"block\", required: false, validate: validateEmailTypes },\n        { key: \"allow\", required: false, validate: validateEmailTypes },\n        { key: \"deny\", required: false, validate: validateEmailTypes },\n        {\n            key: \"requireTopLevelDomain\",\n            required: false,\n            validate: validateBoolean,\n        },\n        { key: \"allowDomainLiteral\", required: false, validate: validateBoolean },\n    ],\n});\nconst validateBotOptions = createValidator({\n    rule: \"detectBot\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n    ],\n});\nconst validateShieldOptions = createValidator({\n    rule: \"shield\",\n    validations: [{ key: \"mode\", required: false, validate: validateMode }],\n});\n/**\n * Validate filter options.\n */\nconst validateFilterOptions = createValidator({\n    rule: \"filter\",\n    validations: [\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n        { key: \"mode\", required: false, validate: validateMode },\n    ],\n});\nconst Priority = {\n    SensitiveInfo: 1,\n    Filter: 2,\n    Shield: 3,\n    RateLimit: 4,\n    BotDetection: 5,\n    EmailValidation: 6,\n};\nfunction isRateLimitRule(rule) {\n    return rule.type === \"RATE_LIMIT\";\n}\n/**\n * Arcjet token bucket rate limiting rule.\n *\n * Applying this rule sets a token bucket rate limit.\n *\n * This algorithm is based on a bucket filled with a specific number of tokens.\n * Each request withdraws some amount of tokens from the bucket and the bucket\n * is refilled at a fixed rate.\n * Once the bucket is empty, the client is blocked until the bucket refills.\n *\n * This algorithm is useful when you want to allow clients to make a burst of\n * requests and then still be able to make requests at a slower rate.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the token bucket rate limiting rule (required).\n * @returns\n *   Token bucket rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   tokenBucket({\n *     mode: \"LIVE\",\n *     refillRate: 10,\n *     interval: \"60s\",\n *     capacity: 100,\n *   });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       tokenBucket({\n *         mode: \"LIVE\",\n *         refillRate: 10,\n *         interval: \"60s\",\n *         capacity: 100,\n *       }),\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#token-bucket\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction tokenBucket(options) {\n    validateTokenBucketOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const refillRate = options.refillRate;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.interval);\n    const capacity = options.capacity;\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"TOKEN_BUCKET\",\n        refillRate,\n        interval,\n        capacity,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"TOKEN_BUCKET\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"refillRate\", refillRate), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"interval\", interval), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"capacity\", capacity));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                    resetTime: new Date(),\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet fixed window rate limiting rule.\n *\n * Applying this rule sets a fixed window rate limit which tracks the number of\n * requests made by a client over a fixed time window.\n *\n * This is the simplest algorithm.\n * It tracks the number of requests made by a client over a fixed time window\n * such as 60 seconds.\n * If the client exceeds the limit, they are blocked until the window expires.\n *\n * This algorithm is useful when you want to apply a simple fixed limit in a\n * fixed time window.\n * For example, a simple limit on the total number of requests a client can make.\n * However, it can be susceptible to the stampede problem where a client makes\n * a burst of requests at the start of a window and then is blocked for the rest\n * of the window.\n * The sliding window algorithm can be used to avoid this.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the fixed window rate limiting rule (required).\n * @returns\n *   Fixed window rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   fixedWindow({ mode: \"LIVE\", window: \"60s\", max: 100 });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *      key: process.env.ARCJET_KEY,\n *     rules: [\n *       fixedWindow({\n *         mode: \"LIVE\",\n *         window: \"60s\",\n *         max: 100,\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#fixed-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction fixedWindow(options) {\n    validateFixedWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const window = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.window);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"FIXED_WINDOW\",\n        max,\n        window,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"FIXED_WINDOW\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"max\", max), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"window\", window));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet sliding window rate limiting rule.\n *\n * Applying this rule sets a sliding window rate limit which tracks the number\n * of requests made by a client over a sliding window so that the window moves\n * with time.\n *\n * This algorithm is useful to avoid the stampede problem of the fixed window.\n * It provides smoother rate limiting over time and can prevent a client from\n * making a burst of requests at the start of a window and then being blocked\n * for the rest of the window.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the sliding window rate limiting rule (required).\n * @returns\n *   Token bucket rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   slidingWindow({ mode: \"LIVE\", interval: \"60s\", max: 100 });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       slidingWindow({\n *         mode: \"LIVE\",\n *         interval: \"60s\",\n *         max: 100,\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#sliding-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction slidingWindow(options) {\n    validateSlidingWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.interval);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"SLIDING_WINDOW\",\n        max,\n        interval,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"SLIDING_WINDOW\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"max\", max), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"interval\", interval));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\nfunction protocolSensitiveInfoEntitiesToAnalyze(entity) {\n    if (typeof entity !== \"string\") {\n        throw new Error(\"invalid entity type\");\n    }\n    if (entity === \"EMAIL\") {\n        return { tag: \"email\" };\n    }\n    if (entity === \"PHONE_NUMBER\") {\n        return { tag: \"phone-number\" };\n    }\n    if (entity === \"IP_ADDRESS\") {\n        return { tag: \"ip-address\" };\n    }\n    if (entity === \"CREDIT_CARD_NUMBER\") {\n        return { tag: \"credit-card-number\" };\n    }\n    return {\n        tag: \"custom\",\n        val: entity,\n    };\n}\nfunction analyzeSensitiveInfoEntitiesToString(entity) {\n    if (entity.tag === \"email\") {\n        return \"EMAIL\";\n    }\n    if (entity.tag === \"ip-address\") {\n        return \"IP_ADDRESS\";\n    }\n    if (entity.tag === \"credit-card-number\") {\n        return \"CREDIT_CARD_NUMBER\";\n    }\n    if (entity.tag === \"phone-number\") {\n        return \"PHONE_NUMBER\";\n    }\n    return entity.val;\n}\nfunction convertAnalyzeDetectedSensitiveInfoEntity(detectedEntities) {\n    return detectedEntities.map((detectedEntity) => {\n        return {\n            ...detectedEntity,\n            identifiedType: analyzeSensitiveInfoEntitiesToString(detectedEntity.identifiedType),\n        };\n    });\n}\n/**\n * Arcjet sensitive information detection rule.\n *\n * Applying this rule protects against clients sending you sensitive information\n * such as personally identifiable information (PII) that you do not wish to\n * handle.\n * The rule runs entirely locally so no data ever leaves your environment.\n *\n * This rule includes built-in detections for email addresses, credit/debit card\n * numbers, IP addresses, and phone numbers.\n * You can also provide a custom detection function to identify additional\n * sensitive information.\n *\n * @template Detect\n *   Custom detection function to identify sensitive information.\n * @template CustomEntities\n *   Custom entities.\n * @param options\n *   Configuration for the sensitive information detection rule (required).\n * @returns\n *   Sensitive information rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   sensitiveInfo({ mode: \"LIVE\", deny: [\"EMAIL\"] });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       sensitiveInfo({\n *         mode: \"LIVE\",\n *         deny: [\"EMAIL\"],\n *       })\n *     ],\n *   });\n *   ```\n * @example\n *   Custom detection function:\n *\n *   ```ts\n *   function detectDash(tokens: string[]): Array<\"CONTAINS_DASH\" | undefined> {\n *     return tokens.map((token) => {\n *       if (token.includes(\"-\")) {\n *         return \"CONTAINS_DASH\";\n *       }\n *     });\n *   }\n *\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       sensitiveInfo({\n *         mode: \"LIVE\",\n *         deny: [\"EMAIL\", \"CONTAINS_DASH\"],\n *         detect: detectDash,\n *         contextWindowSize: 2,\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/sensitive-info/concepts\n * @link https://docs.arcjet.com/sensitive-info/reference\n */\nfunction sensitiveInfo(options) {\n    validateSensitiveInfoOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"SENSITIVE_INFO\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow || [];\n    const deny = options.deny || [];\n    const rule = {\n        version,\n        priority: Priority.SensitiveInfo,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) { },\n        async protect(context, details) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny));\n            const { fingerprint } = context;\n            // No cache is implemented here because the fingerprint can be the same\n            // while the request body changes. This is also why the `sensitiveInfo`\n            // rule results always have a `ttl` of 0.\n            const body = await context.getBody();\n            if (typeof body === \"undefined\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state: \"NOT_RUN\",\n                    conclusion: \"ERROR\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Couldn't read the body of the request to perform sensitive info identification.\"),\n                });\n            }\n            let convertedDetect = undefined;\n            if (typeof options.detect !== \"undefined\") {\n                const detect = options.detect;\n                convertedDetect = (tokens) => {\n                    return detect(tokens)\n                        .filter((e) => typeof e !== \"undefined\")\n                        .map(protocolSensitiveInfoEntitiesToAnalyze);\n                };\n            }\n            let entitiesTag = \"allow\";\n            let entitiesVal = [];\n            if (Array.isArray(options.allow)) {\n                entitiesTag = \"allow\";\n                entitiesVal = options.allow\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            if (Array.isArray(options.deny)) {\n                entitiesTag = \"deny\";\n                entitiesVal = options.deny\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            const entities = {\n                tag: entitiesTag,\n                val: entitiesVal,\n            };\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.detectSensitiveInfo(context, body, entities, options.contextWindowSize || 1, convertedDetect);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            const reason = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason({\n                denied: convertAnalyzeDetectedSensitiveInfoEntity(result.denied),\n                allowed: convertAnalyzeDetectedSensitiveInfoEntity(result.allowed),\n            });\n            if (result.denied.length === 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason,\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason,\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet email validation rule.\n *\n * Applying this rule allows you to validate and verify an email address.\n *\n * The first step of the analysis is to validate the email address syntax.\n * This runs locally within the SDK and validates the email address is in the\n * correct format.\n * If the email syntax is valid, the SDK will pass the email address to the\n * Arcjet cloud API to verify the email address.\n * This performs several checks, depending on the rule configuration.\n *\n * @param options\n *   Configuration for the email validation rule (required).\n * @returns\n *   Email rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   validateEmail({ mode: \"LIVE\", deny: [\"DISPOSABLE\", \"INVALID\"] });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       validateEmail({\n *         mode: \"LIVE\",\n *         deny: [\"DISPOSABLE\", \"INVALID\"]\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/email-validation/concepts\n * @link https://docs.arcjet.com/email-validation/reference\n */\nfunction validateEmail(options) {\n    validateEmailOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `block` cannot be provided together\");\n    }\n    if (typeof options.deny !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `deny` and `block` cannot be provided together, `block` is now deprecated so `deny` should be preferred.\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\" &&\n        typeof options.block === \"undefined\") {\n        throw new Error(\"`validateEmail` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"EMAIL\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? options.block ?? [];\n    const requireTopLevelDomain = options.requireTopLevelDomain ?? true;\n    const allowDomainLiteral = options.allowDomainLiteral ?? false;\n    let config = {\n        tag: \"deny-email-validation-config\",\n        val: {\n            requireTopLevelDomain,\n            allowDomainLiteral,\n            deny: [],\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allow-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                allow: options.allow,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.deny,\n            },\n        };\n    }\n    if (typeof options.block !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.block,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.EmailValidation,\n        type,\n        mode,\n        allow,\n        deny,\n        requireTopLevelDomain,\n        allowDomainLiteral,\n        validate(context, details) {\n            assert(typeof details.email !== \"undefined\", \"ValidateEmail requires `email` to be set.\");\n        },\n        async protect(context, { email }) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.bool(\"requireTopLevelDomain\", requireTopLevelDomain), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.bool(\"allowDomainLiteral\", allowDomainLiteral));\n            const { fingerprint } = context;\n            // No cache is implemented here because the fingerprint can be the same\n            // while the email changes. This is also why the `email` rule results\n            // always have a `ttl` of 0.\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.isValidEmail(context, email, config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            if (result.validity === \"valid\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({ emailTypes: [] }),\n                });\n            }\n            else {\n                const typedEmailTypes = result.blocked.filter(isEmailType);\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({\n                        emailTypes: typedEmailTypes,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet bot detection rule.\n *\n * Applying this rule allows you to manage traffic by automated clients and\n * bots.\n *\n * Bots can be good (such as search engine crawlers or monitoring agents) or bad\n * (such as scrapers or automated scripts).\n * Arcjet allows you to configure which bots you want to allow or deny by\n * specific bot names such as curl, as well as by category such as search\n * engine bots.\n *\n * Bots are detected based on various signals such as the user agent, IP\n * address, DNS records, and more.\n *\n * @param options\n *   Configuration for the bot rule (required).\n * @returns\n *   Bot rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   Allow search engine bots and curl, deny all other bots:\n *\n *   ```ts\n *   detectBot({ mode: \"LIVE\", allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"] });\n *   ```\n * @example\n *   Allow search engine bots and curl, deny all other bots:\n *\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       detectBot({\n *         mode: \"LIVE\",\n *         allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"]\n *       })\n *     ],\n *   });\n *   ```\n * @example\n *   Deny AI crawlers, allow all other bots:\n *\n *   ```ts\n *   detectBot({ mode: \"LIVE\", deny: [\"CATEGORY:AI\"] });\n *   ```\n * @example\n *   Deny AI crawlers, allows all other bots:\n *\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       detectBot({\n *         mode: \"LIVE\",\n *         deny: [\"CATEGORY:AI\"]\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/bot-protection/concepts\n * @link https://docs.arcjet.com/bot-protection/identifying-bots\n * @link https://docs.arcjet.com/bot-protection/reference\n */\nfunction detectBot(options) {\n    validateBotOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`detectBot` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`detectBot` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"BOT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? [];\n    let config = {\n        tag: \"allowed-bot-config\",\n        val: {\n            entities: [],\n            skipCustomDetect: true,\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allowed-bot-config\",\n            val: {\n                entities: options.allow,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"denied-bot-config\",\n            val: {\n                entities: options.deny,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.BotDetection,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) {\n            if (typeof details.headers === \"undefined\") {\n                throw new Error(\"bot detection requires `headers` to be set\");\n            }\n            if (typeof details.headers.has !== \"function\") {\n                throw new Error(\"bot detection requires `headers` to extend `Headers`\");\n            }\n            if (!details.headers.has(\"user-agent\")) {\n                throw new Error(\"bot detection requires user-agent header\");\n            }\n        },\n        /**\n         * Attempts to call the bot detection on the headers.\n         */\n        async protect(context, request) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny));\n            const { fingerprint } = context;\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    reason: cached.reason,\n                });\n            }\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.detectBot(context, toAnalyzeRequest(request), config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            // If this is a bot and of a type that we want to block, then block!\n            if (result.denied.length > 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 60,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet Shield WAF rule.\n *\n * Applying this rule protects your application against common attacks,\n * including the OWASP Top 10.\n *\n * The Arcjet Shield WAF analyzes every request to your application to detect\n * suspicious activity.\n * Once a certain suspicion threshold is reached,\n * subsequent requests from that client are blocked for a period of time.\n *\n * @param options\n *   Configuration for the Shield rule.\n * @returns\n *   Shield rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   shield({ mode: \"LIVE\" });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [shield({ mode: \"LIVE\" })],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/shield/concepts\n * @link https://docs.arcjet.com/shield/reference\n */\nfunction shield(options) {\n    validateShieldOptions(options);\n    const type = \"SHIELD\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const rule = {\n        type,\n        version,\n        priority: Priority.Shield,\n        mode,\n        validate() { },\n        async protect(context, details) {\n            // TODO(#1989): Prefer characteristics defined on rule once available\n            const localCharacteristics = context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    reason: cached.reason,\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason({\n                    shieldTriggered: false,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet signup form protection rule.\n *\n * Applying this rule combines rate limiting, bot protection, and email\n * validation to protect your signup forms from abuse.\n * Using this rule will configure the following:\n *\n * - Rate limiting - signup forms are a common target for bots. Arcjets rate\n *   limiting helps to prevent bots and other automated or malicious clients\n *   from submitting your signup form too many times in a short period of time.\n * - Bot protection - signup forms are usually exclusively used by humans, which\n *   means that any automated submissions to the form are likely to be\n *   fraudulent.\n * - Email validation - email addresses should be validated to ensure the signup\n *   is coming from a legitimate user with a real email address that can\n *   actually receive messages.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the signup form protection rule.\n * @returns\n *   Signup form protection rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   Our recommended configuration for most signup forms is:\n *\n *   - Block email addresses with invalid syntax, that are from disposable email providers,\n *     or do not have valid MX records configured.\n *   - Block all bots.\n *   - Apply a rate limit of 5 submissions per 10 minutes from a single IP\n *     address.\n *\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *      protectSignup({\n *        email: {\n *          mode: \"LIVE\",\n *          block: [\"DISPOSABLE\", \"INVALID\", \"NO_MX_RECORDS\"],\n *        },\n *        bots: {\n *          mode: \"LIVE\",\n *          allow: [], // block all detected bots\n *        },\n *        rateLimit: {\n *          mode: \"LIVE\",\n *          interval: \"10m\",\n *          max: 5,\n *        },\n *      }),\n *    ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/signup-protection/concepts\n * @link https://docs.arcjet.com/signup-protection/reference\n */\nfunction protectSignup(options) {\n    return [\n        ...slidingWindow(options.rateLimit),\n        ...detectBot(options.bots),\n        ...validateEmail(options.email),\n    ];\n}\n/**\n * Arcjet filter rule.\n *\n * Applying this rule lets you block requests using Wireshark-like display\n * filter expressions over HTTP headers, IP addresses, and other request\n * fields.\n * You can quickly enforce rules like allow/deny by country, network, or\n * `user-agent` pattern.\n *\n * See the [reference guide](https://docs.arcjet.com/filters/reference) for\n * more info on the expression language fields, functions, and values.\n *\n * @param options\n *   Configuration (required).\n * @returns\n *   Filter rule.\n *\n * @example\n *   In this example, the expression matches non-VPN GET requests from the US.\n *   Requests matching the expression are allowed, all others are denied.\n *\n *   ```ts\n *   filter({\n *     allow: [\n *       'http.request.method eq \"GET\" and ip.src.country eq \"US\" and not ip.src.vpn',\n *     ],\n *     mode: \"LIVE\",\n *   })\n *   ```\n *\n * @link https://docs.arcjet.com/filters/reference\n */\nfunction filter(options) {\n    validateFilterOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? [];\n    if (allow.length > 0 && deny.length > 0) {\n        throw new Error(\"`filter` options error: expressions must be passed in either `allow` or `deny` instead of both\");\n    }\n    if (allow.length === 0 && deny.length === 0) {\n        throw new Error(\"`filter` options error: one or more expressions must be passed in `allow` or `deny`\");\n    }\n    const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n    const type = \"FILTER\";\n    const version = 0;\n    const ruleIdPromise = _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", \n    // @ts-expect-error: `hasher` must support readonly values.\n    allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", \n    // @ts-expect-error: `hasher` must support readonly values.\n    deny));\n    const rule = {\n        allow,\n        deny,\n        mode,\n        priority: Priority.Filter,\n        async protect(context, request) {\n            const ruleId = await ruleIdPromise;\n            const [cached, ttl] = await context.cache.get(ruleId, context.fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    conclusion: cached.conclusion,\n                    fingerprint: context.fingerprint,\n                    reason: cached.reason,\n                    ruleId,\n                    state: \"CACHED\",\n                    ttl,\n                });\n            }\n            const request_ = toAnalyzeRequest(request);\n            let ruleResult;\n            try {\n                const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.matchFilters(context, request_, allow.length > 0 ? allow : deny, allow.length > 0);\n                ruleResult = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    conclusion: result.allowed ? \"ALLOW\" : \"DENY\",\n                    fingerprint: context.fingerprint,\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetFilterReason(result),\n                    ruleId,\n                    state,\n                    ttl: result.allowed ? 0 : 60,\n                });\n            }\n            catch (error) {\n                ruleResult = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    conclusion: \"ERROR\",\n                    fingerprint: context.fingerprint,\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(error),\n                    ruleId,\n                    state,\n                    ttl: 0,\n                });\n            }\n            return ruleResult;\n        },\n        type,\n        validate() { },\n        version,\n    };\n    return [rule];\n}\n/**\n * Create a new Arcjet instance.\n *\n * @template Rules\n *   List of rules.\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration.\n * @returns\n *   Arcjet instance.\n */\nfunction arcjet(options) {\n    // We destructure here to make the function signature neat when viewed by consumers\n    const { key, rules } = options;\n    const rt = (0,_arcjet_runtime__WEBPACK_IMPORTED_MODULE_4__.runtime)();\n    // TODO: Separate the ArcjetOptions from the SDK Options\n    // It is currently optional in the options so users can override it via an SDK\n    if (typeof options.log === \"undefined\") {\n        throw new Error(\"Log is required\");\n    }\n    const log = options.log;\n    const perf = new Performance(log);\n    // TODO(#207): Remove this when we can default the transport so client is not required\n    // It is currently optional in the options so the Next SDK can override it for the user\n    if (typeof options.client === \"undefined\") {\n        throw new Error(\"Client is required\");\n    }\n    const client = options.client;\n    // A local cache of block decisions. Might be emphemeral per request,\n    // depending on the way the runtime works, but it's worth a try.\n    // TODO(#132): Support configurable caching\n    const cache = new _arcjet_cache__WEBPACK_IMPORTED_MODULE_6__.MemoryCache();\n    const rootRules = rules\n        .flat(1)\n        .sort((a, b) => a.priority - b.priority);\n    async function protect(rules, ctx, request) {\n        // This goes against the type definition above, but users might call\n        // `protect()` with no value and we don't want to crash\n        if (typeof request === \"undefined\") {\n            request = {};\n        }\n        const details = Object.freeze({\n            ip: request.ip,\n            method: request.method,\n            protocol: request.protocol,\n            host: request.host,\n            path: request.path,\n            headers: new _arcjet_headers__WEBPACK_IMPORTED_MODULE_3__.ArcjetHeaders(request.headers),\n            cookies: request.cookies,\n            query: request.query,\n            extra: extraProps(request),\n            email: typeof request.email === \"string\" ? request.email : undefined,\n        });\n        const characteristics = options.characteristics\n            ? [...options.characteristics]\n            : [];\n        const waitUntil = lookupWaitUntil();\n        const baseContext = {\n            key,\n            log,\n            characteristics,\n            waitUntil,\n            ...ctx,\n        };\n        let fingerprint = \"\";\n        const logFingerprintPerf = perf.measure(\"fingerprint\");\n        try {\n            fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(baseContext, toAnalyzeRequest(details));\n            log.debug(\"fingerprint (%s): %s\", rt, fingerprint);\n        }\n        catch (error) {\n            log.error({ error: errorMessage(error) }, \"Failed to build fingerprint. Please verify your Characteristics.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(`Failed to build fingerprint - ${errorMessage(error)}`),\n                // No results because we couldn't create a fingerprint\n                results: [],\n            });\n            // TODO: Consider sending this to Report when we have an infallible fingerprint\n            return decision;\n        }\n        finally {\n            logFingerprintPerf();\n        }\n        const context = Object.freeze({\n            ...baseContext,\n            cache,\n            fingerprint,\n            runtime: rt,\n        });\n        if (rules.length < 1) {\n            log.warn(\"Calling `protect()` with no rules is deprecated. Did you mean to configure the Shield rule?\");\n        }\n        if (rules.length > 10) {\n            log.error(\"Failure running rules. Only 10 rules may be specified.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Only 10 rules may be specified\"),\n                // No results because the sorted rules were too long and we don't want\n                // to instantiate a ton of NOT_RUN results\n                results: [],\n            });\n            client.report(context, details, decision, \n            // No rules because we've determined they were too long and we don't\n            // want to try to send them to the server\n            []);\n            return decision;\n        }\n        const results = [];\n        for (let idx = 0; idx < rules.length; idx++) {\n            // Default all rules to NOT_RUN/ALLOW before doing anything\n            results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                // TODO(#4030): Figure out if we can get each Rule ID before they are run\n                ruleId: \"\",\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason(),\n            });\n            // Add top-level characteristics to all Rate Limit rules that don't already have\n            // their own set of characteristics.\n            const candidate_rule = rules[idx];\n            if (isRateLimitRule(candidate_rule)) {\n                if (typeof candidate_rule.characteristics === \"undefined\") {\n                    candidate_rule.characteristics = characteristics;\n                    rules[idx] = candidate_rule;\n                }\n            }\n        }\n        const logLocalPerf = perf.measure(\"local\");\n        try {\n            for (const [idx, rule] of rules.entries()) {\n                // This re-assignment is a workaround to a TypeScript error with\n                // assertions where the name was introduced via a destructure\n                const localRule = rule;\n                const logRulePerf = perf.measure(rule.type);\n                try {\n                    if (typeof localRule.validate !== \"function\") {\n                        throw new Error(\"rule must have a `validate` function\");\n                    }\n                    localRule.validate(context, details);\n                    if (typeof localRule.protect !== \"function\") {\n                        throw new Error(\"rule must have a `protect` function\");\n                    }\n                    results[idx] = await localRule.protect(context, details);\n                    // If a rule didn't return a rule result, we need to stub it to avoid\n                    // crashing. This should only happen if a user writes a custom local\n                    // rule incorrectly.\n                    if (typeof results[idx] === \"undefined\") {\n                        results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                            // TODO(#4030): If we can get the Rule ID before running rules,\n                            // this can use it\n                            ruleId: \"\",\n                            fingerprint,\n                            ttl: 0,\n                            state: \"RUN\",\n                            conclusion: \"ERROR\",\n                            reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"rule result missing\"),\n                        });\n                    }\n                    log.debug({\n                        id: results[idx].ruleId,\n                        rule: rule.type,\n                        fingerprint,\n                        path: details.path,\n                        runtime: rt,\n                        ttl: results[idx].ttl,\n                        conclusion: results[idx].conclusion,\n                        reason: results[idx].reason,\n                    }, \"Local rule result:\");\n                }\n                catch (err) {\n                    log.error(\"Failure running rule: %s due to %s\", rule.type, errorMessage(err));\n                    results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        // TODO(#4030): Figure out if we can get a Rule ID in this error case\n                        ruleId: \"\",\n                        fingerprint,\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ERROR\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                    });\n                }\n                finally {\n                    logRulePerf();\n                }\n                const result = results[idx];\n                if (result.isDenied()) {\n                    // If the rule is not a DRY_RUN, we want to cache non-zero TTL results\n                    // and return a DENY decision.\n                    if (result.state !== \"DRY_RUN\") {\n                        const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision({\n                            ttl: result.ttl,\n                            reason: result.reason,\n                            results,\n                        });\n                        // Only a DENY decision is reported to avoid creating 2 entries for\n                        // a request. Upon ALLOW, the `decide` call will create an entry for\n                        // the request.\n                        client.report(context, details, decision, rules);\n                        if (result.ttl > 0) {\n                            log.debug({\n                                fingerprint: result.fingerprint,\n                                conclusion: result.conclusion,\n                                reason: result.reason,\n                            }, \"Caching decision for %d seconds\", decision.ttl);\n                            cache.set(result.ruleId, result.fingerprint, {\n                                conclusion: result.conclusion,\n                                reason: result.reason,\n                            }, result.ttl);\n                        }\n                        return decision;\n                    }\n                    log.warn(`Dry run mode is enabled for \"%s\" rule. Overriding decision. Decision was: DENY`, rule.type);\n                }\n            }\n        }\n        finally {\n            logLocalPerf();\n        }\n        // With no cached values, we take a decision remotely. We use a timeout to\n        // fail open.\n        const logRemotePerf = perf.measure(\"remote\");\n        try {\n            const logDediceApiPerf = perf.measure(\"decideApi\");\n            const decision = await client\n                .decide(context, details, rules)\n                .finally(() => {\n                logDediceApiPerf();\n            });\n            // If the decision is to block and we have a non-zero TTL, we cache the\n            // block locally\n            if (decision.isDenied() && decision.ttl > 0) {\n                log.debug(\"decide: Caching block locally for %d seconds\", decision.ttl);\n                for (const result of decision.results) {\n                    // Cache all DENY results for local cache lookups\n                    if (result.conclusion === \"DENY\") {\n                        cache.set(result.ruleId, result.fingerprint, {\n                            conclusion: result.conclusion,\n                            reason: result.reason,\n                        }, result.ttl);\n                    }\n                }\n            }\n            return decision;\n        }\n        catch (err) {\n            log.info(\"Encountered problem getting remote decision: %s\", errorMessage(err));\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                results,\n            });\n            client.report(context, details, decision, rules);\n            return decision;\n        }\n        finally {\n            logRemotePerf();\n        }\n    }\n    // This is a separate function so it can be called recursively\n    function withRule(baseRules, rule) {\n        const rules = [...baseRules, ...rule].sort((a, b) => a.priority - b.priority);\n        return Object.freeze({\n            withRule(rule) {\n                return withRule(rules, rule);\n            },\n            async protect(ctx, request) {\n                return protect(rules, ctx, request);\n            },\n        });\n    }\n    return Object.freeze({\n        /**\n         * Augment the client with another rule.\n         *\n         * Useful for varying rules based on criteria in your handler such as\n         * different rate limit for logged in users.\n         *\n         * @param rule\n         *   Rule to add to Arcjet.\n         * @returns\n         *   Arcjet instance augmented with the given rule.\n         */\n        withRule(rule) {\n            return withRule(rootRules, rule);\n        },\n        /**\n         * Make a decision about how to handle a request.\n         *\n         * This will analyze the request locally where possible and otherwise call\n         * the Arcjet decision API.\n         *\n         * @param ctx\n         *   Additional context for this function call.\n         * @param request\n         *   Details about the {@linkcode ArcjetRequest} that Arcjet needs to make a\n         *   decision.\n         * @returns\n         *   Promise that resolves to an {@linkcode ArcjetDecision} indicating\n         *   Arcjets decision about the request.\n         */\n        async protect(ctx, request) {\n            return protect(rootRules, ctx, request);\n        },\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXJjamV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDK007QUFDM047QUFDVTtBQUNFO0FBQ0c7QUFDTjtBQUNJO0FBQ0Y7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxJQUFJLGdCQUFnQixTQUFTO0FBQ25GO0FBQ0E7QUFDQSxzREFBc0QsSUFBSSx1QkFBdUIsaUJBQWlCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSx1QkFBdUIsMEJB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Q0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRThJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmluYW5jZS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9hcmNqZXQvaW5kZXguanM/NmUxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwcm90b2NvbCBmcm9tICdAYXJjamV0L3Byb3RvY29sJztcbmltcG9ydCB7IEFyY2pldEVycm9yRGVjaXNpb24sIEFyY2pldEVycm9yUmVhc29uLCBBcmNqZXRSdWxlUmVzdWx0LCBBcmNqZXRSZWFzb24sIEFyY2pldERlbnlEZWNpc2lvbiwgQXJjamV0Qm90UmVhc29uLCBBcmNqZXRSYXRlTGltaXRSZWFzb24sIEFyY2pldEVtYWlsUmVhc29uLCBBcmNqZXRTaGllbGRSZWFzb24sIEFyY2pldFNlbnNpdGl2ZUluZm9SZWFzb24sIEFyY2pldEZpbHRlclJlYXNvbiB9IGZyb20gJ0BhcmNqZXQvcHJvdG9jb2wnO1xuZXhwb3J0ICogZnJvbSAnQGFyY2pldC9wcm90b2NvbCc7XG5pbXBvcnQgKiBhcyBhbmFseXplIGZyb20gJ0BhcmNqZXQvYW5hbHl6ZSc7XG5pbXBvcnQgKiBhcyBkdXJhdGlvbiBmcm9tICdAYXJjamV0L2R1cmF0aW9uJztcbmltcG9ydCB7IEFyY2pldEhlYWRlcnMgfSBmcm9tICdAYXJjamV0L2hlYWRlcnMnO1xuaW1wb3J0IHsgcnVudGltZSB9IGZyb20gJ0BhcmNqZXQvcnVudGltZSc7XG5pbXBvcnQgKiBhcyBoYXNoZXIgZnJvbSAnQGFyY2pldC9zdGFibGUtaGFzaCc7XG5pbXBvcnQgeyBNZW1vcnlDYWNoZSB9IGZyb20gJ0BhcmNqZXQvY2FjaGUnO1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvck1lc3NhZ2UoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgXCJtZXNzYWdlXCIgaW4gZXJyICYmXG4gICAgICAgICAgICB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJVbmtub3duIHByb2JsZW1cIjtcbn1cbmNvbnN0IGtub3duRmllbGRzID0gW1xuICAgIFwiaXBcIixcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwicHJvdG9jb2xcIixcbiAgICBcImhvc3RcIixcbiAgICBcInBhdGhcIixcbiAgICBcImhlYWRlcnNcIixcbiAgICBcImJvZHlcIixcbiAgICBcImVtYWlsXCIsXG4gICAgXCJjb29raWVzXCIsXG4gICAgXCJxdWVyeVwiLFxuXTtcbmZ1bmN0aW9uIGlzVW5rbm93blJlcXVlc3RQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gIWtub3duRmllbGRzLmluY2x1ZGVzKGtleSk7XG59XG5mdW5jdGlvbiBpc0VtYWlsVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSBcIkZSRUVcIiB8fFxuICAgICAgICB0eXBlID09PSBcIkRJU1BPU0FCTEVcIiB8fFxuICAgICAgICB0eXBlID09PSBcIk5PX01YX1JFQ09SRFNcIiB8fFxuICAgICAgICB0eXBlID09PSBcIk5PX0dSQVZBVEFSXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJJTlZBTElEXCIpO1xufVxuY2xhc3MgUGVyZm9ybWFuY2Uge1xuICAgIGxvZztcbiAgICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dnZXI7XG4gICAgfVxuICAgIC8vIFRPRE8oIzIwMjApOiBXZSBzaG91bGQgbm8tb3AgdGhpcyBpZiBsb2dsZXZlbCBpcyBub3QgYGRlYnVnYCB0byBkbyBsZXNzIHdvcmtcbiAgICBtZWFzdXJlKGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiTEFURU5DWSAlczogJXNtc1wiLCBsYWJlbCwgZGlmZi50b0ZpeGVkKDMpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiPHVuc3VwcG9ydGVkIHZhbHVlPlwiO1xufVxuLy8gVGhpcyBpcyB0aGUgU3ltYm9sIHRoYXQgVmVyY2VsIGRlZmluZXMgaW4gdGhlaXIgaW5mcmFzdHJ1Y3R1cmUgdG8gYWNjZXNzIHRoZVxuLy8gQ29udGV4dCAod2hlcmUgYXZhaWxhYmxlKS4gVGhlIENvbnRleHQgY2FuIGNvbnRhaW4gdGhlIGB3YWl0VW50aWxgIGZ1bmN0aW9uLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC92ZXJjZWwvYmxvYi85MzBkN2ZiODkyZGMyNmYyNDBmMmI5NTBkOTYzOTMxYzQ1ZTFlNjYxL3BhY2thZ2VzL2Z1bmN0aW9ucy9zcmMvZ2V0LWNvbnRleHQudHMjTDZcbmNvbnN0IFNZTUJPTF9GT1JfUkVRX0NPTlRFWFQgPSBTeW1ib2wuZm9yKFwiQHZlcmNlbC9yZXF1ZXN0LWNvbnRleHRcIik7XG5mdW5jdGlvbiBsb29rdXBXYWl0VW50aWwoKSB7XG4gICAgY29uc3QgZnJvbVN5bWJvbCA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGZyb21TeW1ib2xbU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVF0gIT09IG51bGwgJiZcbiAgICAgICAgXCJnZXRcIiBpbiBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdICYmXG4gICAgICAgIHR5cGVvZiBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdLmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHZlcmNlbEN0eCA9IGZyb21TeW1ib2xbU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVF0uZ2V0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmVyY2VsQ3R4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB2ZXJjZWxDdHggIT09IG51bGwgJiZcbiAgICAgICAgICAgIFwid2FpdFVudGlsXCIgaW4gdmVyY2VsQ3R4ICYmXG4gICAgICAgICAgICB0eXBlb2YgdmVyY2VsQ3R4LndhaXRVbnRpbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVyY2VsQ3R4LndhaXRVbnRpbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQW5hbHl6ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZXF1ZXN0LmhlYWRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICBoZWFkZXJzLFxuICAgIH07XG59XG5mdW5jdGlvbiBleHRyYVByb3BzKGRldGFpbHMpIHtcbiAgICBjb25zdCBleHRyYSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkZXRhaWxzKSkge1xuICAgICAgICBpZiAoaXNVbmtub3duUmVxdWVzdFByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV4dHJhLnNldChrZXksIHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhleHRyYS5lbnRyaWVzKCkpO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVZhbGlkYXRvciguLi50eXBlcykge1xuICAgIHJldHVybiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlT2ZWYWx1ZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKCF0eXBlcy5pbmNsdWRlcyh0eXBlT2ZWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgIC0gZXhwZWN0ZWQgJHt0eXBlc1swXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlIGZvciBcXGAke2tleX1cXGAgLSBleHBlY3RlZCBvbmUgb2YgJHt0eXBlcy5qb2luKFwiLCBcIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmFsdWVWYWxpZGF0b3IoXG4vLyBUaGlzIHVzZXMgdHlwZXMgdG8gZW5zdXJlIHdlIGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXNcbi4uLnZhbHVlcykge1xuICAgIHJldHVybiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBXZSBjYXN0IHRoZSB2YWx1ZXMgdG8gdW5rbm93biBiZWNhdXNlIHRoZSBvcHRpb25WYWx1ZSBpc24ndCBrbm93biBidXRcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHVzZSBgdmFsdWVzYCBvbiBzdHJpbmcgZW51bWVyYXRpb25zXG4gICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHZhbHVlIGZvciBcXGAke2tleX1cXGAgLSBleHBlY3RlZCBvbmUgb2YgJHt2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gYCcke3ZhbHVlfSdgKS5qb2luKFwiLCBcIil9YCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXJyYXlWYWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgICByZXR1cm4gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIGl0ZW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlKGAke2tleX1bJHtpZHh9XWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGUgZm9yIFxcYCR7a2V5fVxcYCAtIGV4cGVjdGVkIGFuIGFycmF5YCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHsgcnVsZSwgdmFsaWRhdGlvbnMsIH0pIHtcbiAgICByZXR1cm4gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSwgdmFsaWRhdGUsIHJlcXVpcmVkIH0gb2YgdmFsaWRhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZCAmJiAhT2JqZWN0Lmhhc093bihvcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke3J1bGV9XFxgIG9wdGlvbnMgZXJyb3I6IFxcYCR7a2V5fVxcYCBpcyByZXF1aXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAvLyBUaGUgYHJlcXVpcmVkYCBmbGFnIGlzIGNoZWNrZWQgYWJvdmUsIHNvIHRoZXNlIHNob3VsZCBvbmx5IGJlIHZhbGlkYXRlZFxuICAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke3J1bGV9XFxgIG9wdGlvbnMgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlKGVycil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHZhbGlkYXRlU3RyaW5nID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcInN0cmluZ1wiKTtcbmNvbnN0IHZhbGlkYXRlTnVtYmVyID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcIm51bWJlclwiKTtcbmNvbnN0IHZhbGlkYXRlQm9vbGVhbiA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJib29sZWFuXCIpO1xuY29uc3QgdmFsaWRhdGVGdW5jdGlvbiA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJmdW5jdGlvblwiKTtcbmNvbnN0IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwic3RyaW5nXCIsIFwibnVtYmVyXCIpO1xuY29uc3QgdmFsaWRhdGVTdHJpbmdBcnJheSA9IGNyZWF0ZUFycmF5VmFsaWRhdG9yKHZhbGlkYXRlU3RyaW5nKTtcbmNvbnN0IHZhbGlkYXRlTW9kZSA9IGNyZWF0ZVZhbHVlVmFsaWRhdG9yKFwiTElWRVwiLCBcIkRSWV9SVU5cIik7XG5jb25zdCB2YWxpZGF0ZUVtYWlsVHlwZXMgPSBjcmVhdGVBcnJheVZhbGlkYXRvcihjcmVhdGVWYWx1ZVZhbGlkYXRvcihcIkRJU1BPU0FCTEVcIiwgXCJGUkVFXCIsIFwiTk9fTVhfUkVDT1JEU1wiLCBcIk5PX0dSQVZBVEFSXCIsIFwiSU5WQUxJRFwiKSk7XG5jb25zdCB2YWxpZGF0ZVRva2VuQnVja2V0T3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJ0b2tlbkJ1Y2tldFwiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtb2RlXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2hhcmFjdGVyaXN0aWNzXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBrZXk6IFwicmVmaWxsUmF0ZVwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgICAgIHsga2V5OiBcImludGVydmFsXCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdPck51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJjYXBhY2l0eVwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVGaXhlZFdpbmRvd09wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwiZml4ZWRXaW5kb3dcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2hhcmFjdGVyaXN0aWNzXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBrZXk6IFwibWF4XCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwid2luZG93XCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdPck51bWJlciB9LFxuICAgIF0sXG59KTtcbmNvbnN0IHZhbGlkYXRlU2xpZGluZ1dpbmRvd09wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwic2xpZGluZ1dpbmRvd1wiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjaGFyYWN0ZXJpc3RpY3NcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7IGtleTogXCJtYXhcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJpbnRlcnZhbFwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZVNlbnNpdGl2ZUluZm9PcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInNlbnNpdGl2ZUluZm9cIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7IGtleTogXCJhbGxvd1wiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgICAgIHsga2V5OiBcImRlbnlcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSB9LFxuICAgICAgICB7IGtleTogXCJjb250ZXh0V2luZG93U2l6ZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJkZXRlY3RcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVGdW5jdGlvbiB9LFxuICAgIF0sXG59KTtcbmNvbnN0IHZhbGlkYXRlRW1haWxPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInZhbGlkYXRlRW1haWxcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7IGtleTogXCJibG9ja1wiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZUVtYWlsVHlwZXMgfSxcbiAgICAgICAgeyBrZXk6IFwiYWxsb3dcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVFbWFpbFR5cGVzIH0sXG4gICAgICAgIHsga2V5OiBcImRlbnlcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVFbWFpbFR5cGVzIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyZXF1aXJlVG9wTGV2ZWxEb21haW5cIixcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUJvb2xlYW4sXG4gICAgICAgIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93RG9tYWluTGl0ZXJhbFwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZUJvb2xlYW4gfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZUJvdE9wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwiZGV0ZWN0Qm90XCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAgeyBrZXk6IFwiYWxsb3dcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSB9LFxuICAgICAgICB7IGtleTogXCJkZW55XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZVNoaWVsZE9wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwic2hpZWxkXCIsXG4gICAgdmFsaWRhdGlvbnM6IFt7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9XSxcbn0pO1xuLyoqXG4gKiBWYWxpZGF0ZSBmaWx0ZXIgb3B0aW9ucy5cbiAqL1xuY29uc3QgdmFsaWRhdGVGaWx0ZXJPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcImZpbHRlclwiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcImFsbG93XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICAgICAgeyBrZXk6IFwiZGVueVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgUHJpb3JpdHkgPSB7XG4gICAgU2Vuc2l0aXZlSW5mbzogMSxcbiAgICBGaWx0ZXI6IDIsXG4gICAgU2hpZWxkOiAzLFxuICAgIFJhdGVMaW1pdDogNCxcbiAgICBCb3REZXRlY3Rpb246IDUsXG4gICAgRW1haWxWYWxpZGF0aW9uOiA2LFxufTtcbmZ1bmN0aW9uIGlzUmF0ZUxpbWl0UnVsZShydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUudHlwZSA9PT0gXCJSQVRFX0xJTUlUXCI7XG59XG4vKipcbiAqIEFyY2pldCB0b2tlbiBidWNrZXQgcmF0ZSBsaW1pdGluZyBydWxlLlxuICpcbiAqIEFwcGx5aW5nIHRoaXMgcnVsZSBzZXRzIGEgdG9rZW4gYnVja2V0IHJhdGUgbGltaXQuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgYmFzZWQgb24gYSBidWNrZXQgZmlsbGVkIHdpdGggYSBzcGVjaWZpYyBudW1iZXIgb2YgdG9rZW5zLlxuICogRWFjaCByZXF1ZXN0IHdpdGhkcmF3cyBzb21lIGFtb3VudCBvZiB0b2tlbnMgZnJvbSB0aGUgYnVja2V0IGFuZCB0aGUgYnVja2V0XG4gKiBpcyByZWZpbGxlZCBhdCBhIGZpeGVkIHJhdGUuXG4gKiBPbmNlIHRoZSBidWNrZXQgaXMgZW1wdHksIHRoZSBjbGllbnQgaXMgYmxvY2tlZCB1bnRpbCB0aGUgYnVja2V0IHJlZmlsbHMuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gYWxsb3cgY2xpZW50cyB0byBtYWtlIGEgYnVyc3Qgb2ZcbiAqIHJlcXVlc3RzIGFuZCB0aGVuIHN0aWxsIGJlIGFibGUgdG8gbWFrZSByZXF1ZXN0cyBhdCBhIHNsb3dlciByYXRlLlxuICpcbiAqIEB0ZW1wbGF0ZSBDaGFyYWN0ZXJpc3RpY3NcbiAqICAgQ2hhcmFjdGVyaXN0aWNzIHRvIHRyYWNrIGEgdXNlciBieS5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIHRoZSB0b2tlbiBidWNrZXQgcmF0ZSBsaW1pdGluZyBydWxlIChyZXF1aXJlZCkuXG4gKiBAcmV0dXJuc1xuICogICBUb2tlbiBidWNrZXQgcnVsZSB0byBwcm92aWRlIHRvIHRoZSBTREsgaW4gdGhlIGBydWxlc2AgZmllbGQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgYGBgdHNcbiAqICAgdG9rZW5CdWNrZXQoe1xuICogICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgIHJlZmlsbFJhdGU6IDEwLFxuICogICAgIGludGVydmFsOiBcIjYwc1wiLFxuICogICAgIGNhcGFjaXR5OiAxMDAsXG4gKiAgIH0pO1xuICogICBgYGBcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgIHRva2VuQnVja2V0KHtcbiAqICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgIHJlZmlsbFJhdGU6IDEwLFxuICogICAgICAgICBpbnRlcnZhbDogXCI2MHNcIixcbiAqICAgICAgICAgY2FwYWNpdHk6IDEwMCxcbiAqICAgICAgIH0pLFxuICogICAgIF0sXG4gKiAgIH0pO1xuICogICBgYGBcbiAqXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2FsZ29yaXRobXMjdG9rZW4tYnVja2V0XG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiB0b2tlbkJ1Y2tldChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVUb2tlbkJ1Y2tldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiUkFURV9MSU1JVFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlZmlsbFJhdGUgPSBvcHRpb25zLnJlZmlsbFJhdGU7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBkdXJhdGlvbi5wYXJzZShvcHRpb25zLmludGVydmFsKTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IG9wdGlvbnMuY2FwYWNpdHk7XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlJhdGVMaW1pdCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhbGdvcml0aG06IFwiVE9LRU5fQlVDS0VUXCIsXG4gICAgICAgIHJlZmlsbFJhdGUsXG4gICAgICAgIGludGVydmFsLFxuICAgICAgICBjYXBhY2l0eSxcbiAgICAgICAgdmFsaWRhdGUoKSB7IH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxDaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3MgPz8gY29udGV4dC5jaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nKFwiYWxnb3JpdGhtXCIsIFwiVE9LRU5fQlVDS0VUXCIpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiY2hhcmFjdGVyaXN0aWNzXCIsIGxvY2FsQ2hhcmFjdGVyaXN0aWNzKSwgXG4gICAgICAgICAgICAvLyBNYXRjaCBpcyBkZXByZWNhdGVkIHNvIGl0IGlzIGFsd2F5cyBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5ld2VzdCBTREtzXG4gICAgICAgICAgICBoYXNoZXIuc3RyaW5nKFwibWF0Y2hcIiwgXCJcIiksIGhhc2hlci51aW50MzIoXCJyZWZpbGxSYXRlXCIsIHJlZmlsbFJhdGUpLCBoYXNoZXIudWludDMyKFwiaW50ZXJ2YWxcIiwgaW50ZXJ2YWwpLCBoYXNoZXIudWludDMyKFwiY2FwYWNpdHlcIiwgY2FwYWNpdHkpKTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5emVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogbG9jYWxDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICAgICAgbG9nOiBjb250ZXh0LmxvZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGF3YWl0IGFuYWx5emUuZ2VuZXJhdGVGaW5nZXJwcmludChhbmFseXplQ29udGV4dCwgdG9BbmFseXplUmVxdWVzdChkZXRhaWxzKSk7XG4gICAgICAgICAgICBjb25zdCBbY2FjaGVkLCB0dGxdID0gYXdhaXQgY29udGV4dC5jYWNoZS5nZXQocnVsZUlkLCBmaW5nZXJwcmludCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5yZWFzb24uaXNSYXRlTGltaXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZWJ1aWxkIHRoZSBgQXJjamV0UmF0ZUxpbWl0UmVhc29uYCBiZWNhdXNlIHdlIG5lZWQgdG8gYWRqdXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVzZXRgIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRpbWUtdG8tbGl2ZVxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSYXRlTGltaXRSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBjYWNoZWQucmVhc29uLm1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZzogY2FjaGVkLnJlYXNvbi5yZW1haW5pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldDogdHRsLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93OiBjYWNoZWQucmVhc29uLndpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0VGltZTogY2FjaGVkLnJlYXNvbi5yZXNldFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcIk5PVF9SVU5cIixcbiAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmF0ZUxpbWl0UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAwLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0VGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IGZpeGVkIHdpbmRvdyByYXRlIGxpbWl0aW5nIHJ1bGUuXG4gKlxuICogQXBwbHlpbmcgdGhpcyBydWxlIHNldHMgYSBmaXhlZCB3aW5kb3cgcmF0ZSBsaW1pdCB3aGljaCB0cmFja3MgdGhlIG51bWJlciBvZlxuICogcmVxdWVzdHMgbWFkZSBieSBhIGNsaWVudCBvdmVyIGEgZml4ZWQgdGltZSB3aW5kb3cuXG4gKlxuICogVGhpcyBpcyB0aGUgc2ltcGxlc3QgYWxnb3JpdGhtLlxuICogSXQgdHJhY2tzIHRoZSBudW1iZXIgb2YgcmVxdWVzdHMgbWFkZSBieSBhIGNsaWVudCBvdmVyIGEgZml4ZWQgdGltZSB3aW5kb3dcbiAqIHN1Y2ggYXMgNjAgc2Vjb25kcy5cbiAqIElmIHRoZSBjbGllbnQgZXhjZWVkcyB0aGUgbGltaXQsIHRoZXkgYXJlIGJsb2NrZWQgdW50aWwgdGhlIHdpbmRvdyBleHBpcmVzLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGFwcGx5IGEgc2ltcGxlIGZpeGVkIGxpbWl0IGluIGFcbiAqIGZpeGVkIHRpbWUgd2luZG93LlxuICogRm9yIGV4YW1wbGUsIGEgc2ltcGxlIGxpbWl0IG9uIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVxdWVzdHMgYSBjbGllbnQgY2FuIG1ha2UuXG4gKiBIb3dldmVyLCBpdCBjYW4gYmUgc3VzY2VwdGlibGUgdG8gdGhlIHN0YW1wZWRlIHByb2JsZW0gd2hlcmUgYSBjbGllbnQgbWFrZXNcbiAqIGEgYnVyc3Qgb2YgcmVxdWVzdHMgYXQgdGhlIHN0YXJ0IG9mIGEgd2luZG93IGFuZCB0aGVuIGlzIGJsb2NrZWQgZm9yIHRoZSByZXN0XG4gKiBvZiB0aGUgd2luZG93LlxuICogVGhlIHNsaWRpbmcgd2luZG93IGFsZ29yaXRobSBjYW4gYmUgdXNlZCB0byBhdm9pZCB0aGlzLlxuICpcbiAqIEB0ZW1wbGF0ZSBDaGFyYWN0ZXJpc3RpY3NcbiAqICAgQ2hhcmFjdGVyaXN0aWNzIHRvIHRyYWNrIGEgdXNlciBieS5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBmaXhlZCB3aW5kb3cgcmF0ZSBsaW1pdGluZyBydWxlIChyZXF1aXJlZCkuXG4gKiBAcmV0dXJuc1xuICogICBGaXhlZCB3aW5kb3cgcnVsZSB0byBwcm92aWRlIHRvIHRoZSBTREsgaW4gdGhlIGBydWxlc2AgZmllbGQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgYGBgdHNcbiAqICAgZml4ZWRXaW5kb3coeyBtb2RlOiBcIkxJVkVcIiwgd2luZG93OiBcIjYwc1wiLCBtYXg6IDEwMCB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgICBydWxlczogW1xuICogICAgICAgZml4ZWRXaW5kb3coe1xuICogICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgd2luZG93OiBcIjYwc1wiLFxuICogICAgICAgICBtYXg6IDEwMCxcbiAqICAgICAgIH0pXG4gKiAgICAgXSxcbiAqICAgfSk7XG4gKiAgIGBgYFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvYWxnb3JpdGhtcyNmaXhlZC13aW5kb3dcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGZpeGVkV2luZG93KG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZUZpeGVkV2luZG93T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB0eXBlID0gXCJSQVRFX0xJTUlUXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGNoYXJhY3RlcmlzdGljcyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3MpXG4gICAgICAgID8gb3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWF4ID0gb3B0aW9ucy5tYXg7XG4gICAgY29uc3Qgd2luZG93ID0gZHVyYXRpb24ucGFyc2Uob3B0aW9ucy53aW5kb3cpO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5SYXRlTGltaXQsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgYWxnb3JpdGhtOiBcIkZJWEVEX1dJTkRPV1wiLFxuICAgICAgICBtYXgsXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdmFsaWRhdGUoKSB7IH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxDaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3MgPz8gY29udGV4dC5jaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nKFwiYWxnb3JpdGhtXCIsIFwiRklYRURfV0lORE9XXCIpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiY2hhcmFjdGVyaXN0aWNzXCIsIGxvY2FsQ2hhcmFjdGVyaXN0aWNzKSwgXG4gICAgICAgICAgICAvLyBNYXRjaCBpcyBkZXByZWNhdGVkIHNvIGl0IGlzIGFsd2F5cyBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5ld2VzdCBTREtzXG4gICAgICAgICAgICBoYXNoZXIuc3RyaW5nKFwibWF0Y2hcIiwgXCJcIiksIGhhc2hlci51aW50MzIoXCJtYXhcIiwgbWF4KSwgaGFzaGVyLnVpbnQzMihcIndpbmRvd1wiLCB3aW5kb3cpKTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5emVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogbG9jYWxDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICAgICAgbG9nOiBjb250ZXh0LmxvZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGF3YWl0IGFuYWx5emUuZ2VuZXJhdGVGaW5nZXJwcmludChhbmFseXplQ29udGV4dCwgdG9BbmFseXplUmVxdWVzdChkZXRhaWxzKSk7XG4gICAgICAgICAgICBjb25zdCBbY2FjaGVkLCB0dGxdID0gYXdhaXQgY29udGV4dC5jYWNoZS5nZXQocnVsZUlkLCBmaW5nZXJwcmludCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5yZWFzb24uaXNSYXRlTGltaXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZWJ1aWxkIHRoZSBgQXJjamV0UmF0ZUxpbWl0UmVhc29uYCBiZWNhdXNlIHdlIG5lZWQgdG8gYWRqdXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVzZXRgIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRpbWUtdG8tbGl2ZVxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSYXRlTGltaXRSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBjYWNoZWQucmVhc29uLm1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZzogY2FjaGVkLnJlYXNvbi5yZW1haW5pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldDogdHRsLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93OiBjYWNoZWQucmVhc29uLndpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0VGltZTogY2FjaGVkLnJlYXNvbi5yZXNldFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcIk5PVF9SVU5cIixcbiAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmF0ZUxpbWl0UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAwLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IDAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBzbGlkaW5nIHdpbmRvdyByYXRlIGxpbWl0aW5nIHJ1bGUuXG4gKlxuICogQXBwbHlpbmcgdGhpcyBydWxlIHNldHMgYSBzbGlkaW5nIHdpbmRvdyByYXRlIGxpbWl0IHdoaWNoIHRyYWNrcyB0aGUgbnVtYmVyXG4gKiBvZiByZXF1ZXN0cyBtYWRlIGJ5IGEgY2xpZW50IG92ZXIgYSBzbGlkaW5nIHdpbmRvdyBzbyB0aGF0IHRoZSB3aW5kb3cgbW92ZXNcbiAqIHdpdGggdGltZS5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyB1c2VmdWwgdG8gYXZvaWQgdGhlIHN0YW1wZWRlIHByb2JsZW0gb2YgdGhlIGZpeGVkIHdpbmRvdy5cbiAqIEl0IHByb3ZpZGVzIHNtb290aGVyIHJhdGUgbGltaXRpbmcgb3ZlciB0aW1lIGFuZCBjYW4gcHJldmVudCBhIGNsaWVudCBmcm9tXG4gKiBtYWtpbmcgYSBidXJzdCBvZiByZXF1ZXN0cyBhdCB0aGUgc3RhcnQgb2YgYSB3aW5kb3cgYW5kIHRoZW4gYmVpbmcgYmxvY2tlZFxuICogZm9yIHRoZSByZXN0IG9mIHRoZSB3aW5kb3cuXG4gKlxuICogQHRlbXBsYXRlIENoYXJhY3RlcmlzdGljc1xuICogICBDaGFyYWN0ZXJpc3RpY3MgdG8gdHJhY2sgYSB1c2VyIGJ5LlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgdGhlIHNsaWRpbmcgd2luZG93IHJhdGUgbGltaXRpbmcgcnVsZSAocmVxdWlyZWQpLlxuICogQHJldHVybnNcbiAqICAgVG9rZW4gYnVja2V0IHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgIGZpZWxkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIHNsaWRpbmdXaW5kb3coeyBtb2RlOiBcIkxJVkVcIiwgaW50ZXJ2YWw6IFwiNjBzXCIsIG1heDogMTAwIH0pO1xuICogICBgYGBcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgIHNsaWRpbmdXaW5kb3coe1xuICogICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgaW50ZXJ2YWw6IFwiNjBzXCIsXG4gKiAgICAgICAgIG1heDogMTAwLFxuICogICAgICAgfSlcbiAqICAgICBdLFxuICogICB9KTtcbiAqICAgYGBgXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vcmF0ZS1saW1pdGluZy9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vcmF0ZS1saW1pdGluZy9hbGdvcml0aG1zI3NsaWRpbmctd2luZG93XG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBzbGlkaW5nV2luZG93KG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZVNsaWRpbmdXaW5kb3dPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHR5cGUgPSBcIlJBVEVfTElNSVRcIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmNoYXJhY3RlcmlzdGljcylcbiAgICAgICAgPyBvcHRpb25zLmNoYXJhY3RlcmlzdGljc1xuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtYXggPSBvcHRpb25zLm1heDtcbiAgICBjb25zdCBpbnRlcnZhbCA9IGR1cmF0aW9uLnBhcnNlKG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5SYXRlTGltaXQsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgYWxnb3JpdGhtOiBcIlNMSURJTkdfV0lORE9XXCIsXG4gICAgICAgIG1heCxcbiAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgIHZhbGlkYXRlKCkgeyB9LFxuICAgICAgICBhc3luYyBwcm90ZWN0KGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQ2hhcmFjdGVyaXN0aWNzID0gY2hhcmFjdGVyaXN0aWNzID8/IGNvbnRleHQuY2hhcmFjdGVyaXN0aWNzO1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZyhcImFsZ29yaXRobVwiLCBcIlNMSURJTkdfV0lORE9XXCIpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiY2hhcmFjdGVyaXN0aWNzXCIsIGxvY2FsQ2hhcmFjdGVyaXN0aWNzKSwgXG4gICAgICAgICAgICAvLyBNYXRjaCBpcyBkZXByZWNhdGVkIHNvIGl0IGlzIGFsd2F5cyBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5ld2VzdCBTREtzXG4gICAgICAgICAgICBoYXNoZXIuc3RyaW5nKFwibWF0Y2hcIiwgXCJcIiksIGhhc2hlci51aW50MzIoXCJtYXhcIiwgbWF4KSwgaGFzaGVyLnVpbnQzMihcImludGVydmFsXCIsIGludGVydmFsKSk7XG4gICAgICAgICAgICBjb25zdCBhbmFseXplQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IGxvY2FsQ2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgICAgIGxvZzogY29udGV4dC5sb2csXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBhd2FpdCBhbmFseXplLmdlbmVyYXRlRmluZ2VycHJpbnQoYW5hbHl6ZUNvbnRleHQsIHRvQW5hbHl6ZVJlcXVlc3QoZGV0YWlscykpO1xuICAgICAgICAgICAgY29uc3QgW2NhY2hlZCwgdHRsXSA9IGF3YWl0IGNvbnRleHQuY2FjaGUuZ2V0KHJ1bGVJZCwgZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQucmVhc29uLmlzUmF0ZUxpbWl0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIkNBQ0hFRFwiLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBjYWNoZWQuY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmVidWlsZCB0aGUgYEFyY2pldFJhdGVMaW1pdFJlYXNvbmAgYmVjYXVzZSB3ZSBuZWVkIHRvIGFkanVzdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlc2V0YCBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lLXRvLWxpdmVcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmF0ZUxpbWl0UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogY2FjaGVkLnJlYXNvbi5tYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmc6IGNhY2hlZC5yZWFzb24ucmVtYWluaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IHR0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogY2FjaGVkLnJlYXNvbi53aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFRpbWU6IGNhY2hlZC5yZWFzb24ucmVzZXRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJOT1RfUlVOXCIsXG4gICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFJhdGVMaW1pdFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIG1heDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiAwLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuZnVuY3Rpb24gcHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUoZW50aXR5KSB7XG4gICAgaWYgKHR5cGVvZiBlbnRpdHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbnRpdHkgdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKGVudGl0eSA9PT0gXCJFTUFJTFwiKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJlbWFpbFwiIH07XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiUEhPTkVfTlVNQkVSXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcInBob25lLW51bWJlclwiIH07XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiSVBfQUREUkVTU1wiKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJpcC1hZGRyZXNzXCIgfTtcbiAgICB9XG4gICAgaWYgKGVudGl0eSA9PT0gXCJDUkVESVRfQ0FSRF9OVU1CRVJcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiY3JlZGl0LWNhcmQtbnVtYmVyXCIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiBcImN1c3RvbVwiLFxuICAgICAgICB2YWw6IGVudGl0eSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYW5hbHl6ZVNlbnNpdGl2ZUluZm9FbnRpdGllc1RvU3RyaW5nKGVudGl0eSkge1xuICAgIGlmIChlbnRpdHkudGFnID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiRU1BSUxcIjtcbiAgICB9XG4gICAgaWYgKGVudGl0eS50YWcgPT09IFwiaXAtYWRkcmVzc1wiKSB7XG4gICAgICAgIHJldHVybiBcIklQX0FERFJFU1NcIjtcbiAgICB9XG4gICAgaWYgKGVudGl0eS50YWcgPT09IFwiY3JlZGl0LWNhcmQtbnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiQ1JFRElUX0NBUkRfTlVNQkVSXCI7XG4gICAgfVxuICAgIGlmIChlbnRpdHkudGFnID09PSBcInBob25lLW51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcIlBIT05FX05VTUJFUlwiO1xuICAgIH1cbiAgICByZXR1cm4gZW50aXR5LnZhbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBbmFseXplRGV0ZWN0ZWRTZW5zaXRpdmVJbmZvRW50aXR5KGRldGVjdGVkRW50aXRpZXMpIHtcbiAgICByZXR1cm4gZGV0ZWN0ZWRFbnRpdGllcy5tYXAoKGRldGVjdGVkRW50aXR5KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kZXRlY3RlZEVudGl0eSxcbiAgICAgICAgICAgIGlkZW50aWZpZWRUeXBlOiBhbmFseXplU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9TdHJpbmcoZGV0ZWN0ZWRFbnRpdHkuaWRlbnRpZmllZFR5cGUpLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuLyoqXG4gKiBBcmNqZXQgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGRldGVjdGlvbiBydWxlLlxuICpcbiAqIEFwcGx5aW5nIHRoaXMgcnVsZSBwcm90ZWN0cyBhZ2FpbnN0IGNsaWVudHMgc2VuZGluZyB5b3Ugc2Vuc2l0aXZlIGluZm9ybWF0aW9uXG4gKiBzdWNoIGFzIHBlcnNvbmFsbHkgaWRlbnRpZmlhYmxlIGluZm9ybWF0aW9uIChQSUkpIHRoYXQgeW91IGRvIG5vdCB3aXNoIHRvXG4gKiBoYW5kbGUuXG4gKiBUaGUgcnVsZSBydW5zIGVudGlyZWx5IGxvY2FsbHkgc28gbm8gZGF0YSBldmVyIGxlYXZlcyB5b3VyIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgcnVsZSBpbmNsdWRlcyBidWlsdC1pbiBkZXRlY3Rpb25zIGZvciBlbWFpbCBhZGRyZXNzZXMsIGNyZWRpdC9kZWJpdCBjYXJkXG4gKiBudW1iZXJzLCBJUCBhZGRyZXNzZXMsIGFuZCBwaG9uZSBudW1iZXJzLlxuICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBjdXN0b20gZGV0ZWN0aW9uIGZ1bmN0aW9uIHRvIGlkZW50aWZ5IGFkZGl0aW9uYWxcbiAqIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgRGV0ZWN0XG4gKiAgIEN1c3RvbSBkZXRlY3Rpb24gZnVuY3Rpb24gdG8gaWRlbnRpZnkgc2Vuc2l0aXZlIGluZm9ybWF0aW9uLlxuICogQHRlbXBsYXRlIEN1c3RvbUVudGl0aWVzXG4gKiAgIEN1c3RvbSBlbnRpdGllcy5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzZW5zaXRpdmUgaW5mb3JtYXRpb24gZGV0ZWN0aW9uIHJ1bGUgKHJlcXVpcmVkKS5cbiAqIEByZXR1cm5zXG4gKiAgIFNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYCBmaWVsZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBzZW5zaXRpdmVJbmZvKHsgbW9kZTogXCJMSVZFXCIsIGRlbnk6IFtcIkVNQUlMXCJdIH0pO1xuICogICBgYGBcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgIHNlbnNpdGl2ZUluZm8oe1xuICogICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgZGVueTogW1wiRU1BSUxcIl0sXG4gKiAgICAgICB9KVxuICogICAgIF0sXG4gKiAgIH0pO1xuICogICBgYGBcbiAqIEBleGFtcGxlXG4gKiAgIEN1c3RvbSBkZXRlY3Rpb24gZnVuY3Rpb246XG4gKlxuICogICBgYGB0c1xuICogICBmdW5jdGlvbiBkZXRlY3REYXNoKHRva2Vuczogc3RyaW5nW10pOiBBcnJheTxcIkNPTlRBSU5TX0RBU0hcIiB8IHVuZGVmaW5lZD4ge1xuICogICAgIHJldHVybiB0b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICogICAgICAgaWYgKHRva2VuLmluY2x1ZGVzKFwiLVwiKSkge1xuICogICAgICAgICByZXR1cm4gXCJDT05UQUlOU19EQVNIXCI7XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgIH1cbiAqXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgIHNlbnNpdGl2ZUluZm8oe1xuICogICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgZGVueTogW1wiRU1BSUxcIiwgXCJDT05UQUlOU19EQVNIXCJdLFxuICogICAgICAgICBkZXRlY3Q6IGRldGVjdERhc2gsXG4gKiAgICAgICAgIGNvbnRleHRXaW5kb3dTaXplOiAyLFxuICogICAgICAgfSlcbiAqICAgICBdLFxuICogICB9KTtcbiAqICAgYGBgXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vc2Vuc2l0aXZlLWluZm8vY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NlbnNpdGl2ZS1pbmZvL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBzZW5zaXRpdmVJbmZvKG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZVNlbnNpdGl2ZUluZm9PcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzZW5zaXRpdmVJbmZvYCBvcHRpb25zIGVycm9yOiBgYWxsb3dgIGFuZCBgZGVueWAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuZGVueSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgc2Vuc2l0aXZlSW5mb2Agb3B0aW9ucyBlcnJvcjogZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gXCJTRU5TSVRJVkVfSU5GT1wiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBhbGxvdyA9IG9wdGlvbnMuYWxsb3cgfHwgW107XG4gICAgY29uc3QgZGVueSA9IG9wdGlvbnMuZGVueSB8fCBbXTtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuU2Vuc2l0aXZlSW5mbyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgYWxsb3csXG4gICAgICAgIGRlbnksXG4gICAgICAgIHZhbGlkYXRlKGNvbnRleHQsIGRldGFpbHMpIHsgfSxcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiYWxsb3dcIiwgYWxsb3cpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiZGVueVwiLCBkZW55KSk7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmdlcnByaW50IH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgLy8gTm8gY2FjaGUgaXMgaW1wbGVtZW50ZWQgaGVyZSBiZWNhdXNlIHRoZSBmaW5nZXJwcmludCBjYW4gYmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHdoaWxlIHRoZSByZXF1ZXN0IGJvZHkgY2hhbmdlcy4gVGhpcyBpcyBhbHNvIHdoeSB0aGUgYHNlbnNpdGl2ZUluZm9gXG4gICAgICAgICAgICAvLyBydWxlIHJlc3VsdHMgYWx3YXlzIGhhdmUgYSBgdHRsYCBvZiAwLlxuICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IGNvbnRleHQuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJOT1RfUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oXCJDb3VsZG4ndCByZWFkIHRoZSBib2R5IG9mIHRoZSByZXF1ZXN0IHRvIHBlcmZvcm0gc2Vuc2l0aXZlIGluZm8gaWRlbnRpZmljYXRpb24uXCIpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbnZlcnRlZERldGVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXRlY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3QgPSBvcHRpb25zLmRldGVjdDtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWREZXRlY3QgPSAodG9rZW5zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXRlY3QodG9rZW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gdHlwZW9mIGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKHByb3RvY29sU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9BbmFseXplKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVudGl0aWVzVGFnID0gXCJhbGxvd1wiO1xuICAgICAgICAgICAgbGV0IGVudGl0aWVzVmFsID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmFsbG93KSkge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzVGFnID0gXCJhbGxvd1wiO1xuICAgICAgICAgICAgICAgIGVudGl0aWVzVmFsID0gb3B0aW9ucy5hbGxvd1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlKSA9PiB0eXBlb2YgZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgLm1hcChwcm90b2NvbFNlbnNpdGl2ZUluZm9FbnRpdGllc1RvQW5hbHl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmRlbnkpKSB7XG4gICAgICAgICAgICAgICAgZW50aXRpZXNUYWcgPSBcImRlbnlcIjtcbiAgICAgICAgICAgICAgICBlbnRpdGllc1ZhbCA9IG9wdGlvbnMuZGVueVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlKSA9PiB0eXBlb2YgZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgLm1hcChwcm90b2NvbFNlbnNpdGl2ZUluZm9FbnRpdGllc1RvQW5hbHl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbnRpdGllcyA9IHtcbiAgICAgICAgICAgICAgICB0YWc6IGVudGl0aWVzVGFnLFxuICAgICAgICAgICAgICAgIHZhbDogZW50aXRpZXNWYWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZS5kZXRlY3RTZW5zaXRpdmVJbmZvKGNvbnRleHQsIGJvZHksIGVudGl0aWVzLCBvcHRpb25zLmNvbnRleHRXaW5kb3dTaXplIHx8IDEsIGNvbnZlcnRlZERldGVjdCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IG1vZGUgPT09IFwiTElWRVwiID8gXCJSVU5cIiA6IFwiRFJZX1JVTlwiO1xuICAgICAgICAgICAgY29uc3QgcmVhc29uID0gbmV3IEFyY2pldFNlbnNpdGl2ZUluZm9SZWFzb24oe1xuICAgICAgICAgICAgICAgIGRlbmllZDogY29udmVydEFuYWx5emVEZXRlY3RlZFNlbnNpdGl2ZUluZm9FbnRpdHkocmVzdWx0LmRlbmllZCksXG4gICAgICAgICAgICAgICAgYWxsb3dlZDogY29udmVydEFuYWx5emVEZXRlY3RlZFNlbnNpdGl2ZUluZm9FbnRpdHkocmVzdWx0LmFsbG93ZWQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRlbmllZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiREVOWVwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuLyoqXG4gKiBBcmNqZXQgZW1haWwgdmFsaWRhdGlvbiBydWxlLlxuICpcbiAqIEFwcGx5aW5nIHRoaXMgcnVsZSBhbGxvd3MgeW91IHRvIHZhbGlkYXRlIGFuZCB2ZXJpZnkgYW4gZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBUaGUgZmlyc3Qgc3RlcCBvZiB0aGUgYW5hbHlzaXMgaXMgdG8gdmFsaWRhdGUgdGhlIGVtYWlsIGFkZHJlc3Mgc3ludGF4LlxuICogVGhpcyBydW5zIGxvY2FsbHkgd2l0aGluIHRoZSBTREsgYW5kIHZhbGlkYXRlcyB0aGUgZW1haWwgYWRkcmVzcyBpcyBpbiB0aGVcbiAqIGNvcnJlY3QgZm9ybWF0LlxuICogSWYgdGhlIGVtYWlsIHN5bnRheCBpcyB2YWxpZCwgdGhlIFNESyB3aWxsIHBhc3MgdGhlIGVtYWlsIGFkZHJlc3MgdG8gdGhlXG4gKiBBcmNqZXQgY2xvdWQgQVBJIHRvIHZlcmlmeSB0aGUgZW1haWwgYWRkcmVzcy5cbiAqIFRoaXMgcGVyZm9ybXMgc2V2ZXJhbCBjaGVja3MsIGRlcGVuZGluZyBvbiB0aGUgcnVsZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBlbWFpbCB2YWxpZGF0aW9uIHJ1bGUgKHJlcXVpcmVkKS5cbiAqIEByZXR1cm5zXG4gKiAgIEVtYWlsIHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgIGZpZWxkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIHZhbGlkYXRlRW1haWwoeyBtb2RlOiBcIkxJVkVcIiwgZGVueTogW1wiRElTUE9TQUJMRVwiLCBcIklOVkFMSURcIl0gfSk7XG4gKiAgIGBgYFxuICogQGV4YW1wbGVcbiAqICAgYGBgdHNcbiAqICAgY29uc3QgYWogPSBhcmNqZXQoe1xuICogICAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgICBydWxlczogW1xuICogICAgICAgdmFsaWRhdGVFbWFpbCh7XG4gKiAgICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgICBkZW55OiBbXCJESVNQT1NBQkxFXCIsIFwiSU5WQUxJRFwiXVxuICogICAgICAgfSlcbiAqICAgICBdLFxuICogICB9KTtcbiAqICAgYGBgXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vZW1haWwtdmFsaWRhdGlvbi9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vZW1haWwtdmFsaWRhdGlvbi9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFbWFpbChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVFbWFpbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHZhbGlkYXRlRW1haWxgIG9wdGlvbnMgZXJyb3I6IGBhbGxvd2AgYW5kIGBkZW55YCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5ibG9jayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdmFsaWRhdGVFbWFpbGAgb3B0aW9ucyBlcnJvcjogYGFsbG93YCBhbmQgYGJsb2NrYCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJsb2NrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImB2YWxpZGF0ZUVtYWlsYCBvcHRpb25zIGVycm9yOiBgZGVueWAgYW5kIGBibG9ja2AgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyLCBgYmxvY2tgIGlzIG5vdyBkZXByZWNhdGVkIHNvIGBkZW55YCBzaG91bGQgYmUgcHJlZmVycmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmxvY2sgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHZhbGlkYXRlRW1haWxgIG9wdGlvbnMgZXJyb3I6IGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFwiRU1BSUxcIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLmFsbG93ID8/IFtdO1xuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLmRlbnkgPz8gb3B0aW9ucy5ibG9jayA/PyBbXTtcbiAgICBjb25zdCByZXF1aXJlVG9wTGV2ZWxEb21haW4gPSBvcHRpb25zLnJlcXVpcmVUb3BMZXZlbERvbWFpbiA/PyB0cnVlO1xuICAgIGNvbnN0IGFsbG93RG9tYWluTGl0ZXJhbCA9IG9wdGlvbnMuYWxsb3dEb21haW5MaXRlcmFsID8/IGZhbHNlO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIHRhZzogXCJkZW55LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgIHZhbDoge1xuICAgICAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgZGVueTogW10sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgdGFnOiBcImFsbG93LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlVG9wTGV2ZWxEb21haW4sXG4gICAgICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmFsbG93LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlbnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgdGFnOiBcImRlbnktZW1haWwtdmFsaWRhdGlvbi1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVUb3BMZXZlbERvbWFpbixcbiAgICAgICAgICAgICAgICBhbGxvd0RvbWFpbkxpdGVyYWwsXG4gICAgICAgICAgICAgICAgZGVueTogb3B0aW9ucy5kZW55LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmJsb2NrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJkZW55LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlVG9wTGV2ZWxEb21haW4sXG4gICAgICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIGRlbnk6IG9wdGlvbnMuYmxvY2ssXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuRW1haWxWYWxpZGF0aW9uLFxuICAgICAgICB0eXBlLFxuICAgICAgICBtb2RlLFxuICAgICAgICBhbGxvdyxcbiAgICAgICAgZGVueSxcbiAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICBhbGxvd0RvbWFpbkxpdGVyYWwsXG4gICAgICAgIHZhbGlkYXRlKGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgZGV0YWlscy5lbWFpbCAhPT0gXCJ1bmRlZmluZWRcIiwgXCJWYWxpZGF0ZUVtYWlsIHJlcXVpcmVzIGBlbWFpbGAgdG8gYmUgc2V0LlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCB7IGVtYWlsIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IGF3YWl0IGhhc2hlci5oYXNoKGhhc2hlci5zdHJpbmcoXCJ0eXBlXCIsIHR5cGUpLCBoYXNoZXIudWludDMyKFwidmVyc2lvblwiLCB2ZXJzaW9uKSwgaGFzaGVyLnN0cmluZyhcIm1vZGVcIiwgbW9kZSksIGhhc2hlci5zdHJpbmdTbGljZU9yZGVyZWQoXCJhbGxvd1wiLCBhbGxvdyksIGhhc2hlci5zdHJpbmdTbGljZU9yZGVyZWQoXCJkZW55XCIsIGRlbnkpLCBoYXNoZXIuYm9vbChcInJlcXVpcmVUb3BMZXZlbERvbWFpblwiLCByZXF1aXJlVG9wTGV2ZWxEb21haW4pLCBoYXNoZXIuYm9vbChcImFsbG93RG9tYWluTGl0ZXJhbFwiLCBhbGxvd0RvbWFpbkxpdGVyYWwpKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZmluZ2VycHJpbnQgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAvLyBObyBjYWNoZSBpcyBpbXBsZW1lbnRlZCBoZXJlIGJlY2F1c2UgdGhlIGZpbmdlcnByaW50IGNhbiBiZSB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gd2hpbGUgdGhlIGVtYWlsIGNoYW5nZXMuIFRoaXMgaXMgYWxzbyB3aHkgdGhlIGBlbWFpbGAgcnVsZSByZXN1bHRzXG4gICAgICAgICAgICAvLyBhbHdheXMgaGF2ZSBhIGB0dGxgIG9mIDAuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplLmlzVmFsaWRFbWFpbChjb250ZXh0LCBlbWFpbCwgY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gbW9kZSA9PT0gXCJMSVZFXCIgPyBcIlJVTlwiIDogXCJEUllfUlVOXCI7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbGlkaXR5ID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVtYWlsUmVhc29uKHsgZW1haWxUeXBlczogW10gfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEVtYWlsVHlwZXMgPSByZXN1bHQuYmxvY2tlZC5maWx0ZXIoaXNFbWFpbFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiREVOWVwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFbWFpbFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbFR5cGVzOiB0eXBlZEVtYWlsVHlwZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IGJvdCBkZXRlY3Rpb24gcnVsZS5cbiAqXG4gKiBBcHBseWluZyB0aGlzIHJ1bGUgYWxsb3dzIHlvdSB0byBtYW5hZ2UgdHJhZmZpYyBieSBhdXRvbWF0ZWQgY2xpZW50cyBhbmRcbiAqIGJvdHMuXG4gKlxuICogQm90cyBjYW4gYmUgZ29vZCAoc3VjaCBhcyBzZWFyY2ggZW5naW5lIGNyYXdsZXJzIG9yIG1vbml0b3JpbmcgYWdlbnRzKSBvciBiYWRcbiAqIChzdWNoIGFzIHNjcmFwZXJzIG9yIGF1dG9tYXRlZCBzY3JpcHRzKS5cbiAqIEFyY2pldCBhbGxvd3MgeW91IHRvIGNvbmZpZ3VyZSB3aGljaCBib3RzIHlvdSB3YW50IHRvIGFsbG93IG9yIGRlbnkgYnlcbiAqIHNwZWNpZmljIGJvdCBuYW1lcyBzdWNoIGFzIGN1cmwsIGFzIHdlbGwgYXMgYnkgY2F0ZWdvcnkgc3VjaCBhcyBzZWFyY2hcbiAqIGVuZ2luZSBib3RzLlxuICpcbiAqIEJvdHMgYXJlIGRldGVjdGVkIGJhc2VkIG9uIHZhcmlvdXMgc2lnbmFscyBzdWNoIGFzIHRoZSB1c2VyIGFnZW50LCBJUFxuICogYWRkcmVzcywgRE5TIHJlY29yZHMsIGFuZCBtb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBib3QgcnVsZSAocmVxdWlyZWQpLlxuICogQHJldHVybnNcbiAqICAgQm90IHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgIGZpZWxkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIEFsbG93IHNlYXJjaCBlbmdpbmUgYm90cyBhbmQgY3VybCwgZGVueSBhbGwgb3RoZXIgYm90czpcbiAqXG4gKiAgIGBgYHRzXG4gKiAgIGRldGVjdEJvdCh7IG1vZGU6IFwiTElWRVwiLCBhbGxvdzogW1wiQ0FURUdPUlk6U0VBUkNIX0VOR0lORVwiLCBcIkNVUkxcIl0gfSk7XG4gKiAgIGBgYFxuICogQGV4YW1wbGVcbiAqICAgQWxsb3cgc2VhcmNoIGVuZ2luZSBib3RzIGFuZCBjdXJsLCBkZW55IGFsbCBvdGhlciBib3RzOlxuICpcbiAqICAgYGBgdHNcbiAqICAgY29uc3QgYWogPSBhcmNqZXQoe1xuICogICAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgICBydWxlczogW1xuICogICAgICAgZGV0ZWN0Qm90KHtcbiAqICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgIGFsbG93OiBbXCJDQVRFR09SWTpTRUFSQ0hfRU5HSU5FXCIsIFwiQ1VSTFwiXVxuICogICAgICAgfSlcbiAqICAgICBdLFxuICogICB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBEZW55IEFJIGNyYXdsZXJzLCBhbGxvdyBhbGwgb3RoZXIgYm90czpcbiAqXG4gKiAgIGBgYHRzXG4gKiAgIGRldGVjdEJvdCh7IG1vZGU6IFwiTElWRVwiLCBkZW55OiBbXCJDQVRFR09SWTpBSVwiXSB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBEZW55IEFJIGNyYXdsZXJzLCBhbGxvd3MgYWxsIG90aGVyIGJvdHM6XG4gKlxuICogICBgYGB0c1xuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICAgIHJ1bGVzOiBbXG4gKiAgICAgICBkZXRlY3RCb3Qoe1xuICogICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgZGVueTogW1wiQ0FURUdPUlk6QUlcIl1cbiAqICAgICAgIH0pXG4gKiAgICAgXSxcbiAqICAgfSk7XG4gKiAgIGBgYFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2JvdC1wcm90ZWN0aW9uL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9pZGVudGlmeWluZy1ib3RzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gZGV0ZWN0Qm90KG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZUJvdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGRldGVjdEJvdGAgb3B0aW9ucyBlcnJvcjogYGFsbG93YCBhbmQgYGRlbnlgIGNhbm5vdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGRldGVjdEJvdGAgb3B0aW9ucyBlcnJvcjogZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gXCJCT1RcIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLmFsbG93ID8/IFtdO1xuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLmRlbnkgPz8gW107XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgdGFnOiBcImFsbG93ZWQtYm90LWNvbmZpZ1wiLFxuICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgIGVudGl0aWVzOiBbXSxcbiAgICAgICAgICAgIHNraXBDdXN0b21EZXRlY3Q6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgdGFnOiBcImFsbG93ZWQtYm90LWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgZW50aXRpZXM6IG9wdGlvbnMuYWxsb3csXG4gICAgICAgICAgICAgICAgc2tpcEN1c3RvbURldGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJkZW5pZWQtYm90LWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgZW50aXRpZXM6IG9wdGlvbnMuZGVueSxcbiAgICAgICAgICAgICAgICBza2lwQ3VzdG9tRGV0ZWN0OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LkJvdERldGVjdGlvbixcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgYWxsb3csXG4gICAgICAgIGRlbnksXG4gICAgICAgIHZhbGlkYXRlKGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlscy5oZWFkZXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm90IGRldGVjdGlvbiByZXF1aXJlcyBgaGVhZGVyc2AgdG8gYmUgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXRhaWxzLmhlYWRlcnMuaGFzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib3QgZGV0ZWN0aW9uIHJlcXVpcmVzIGBoZWFkZXJzYCB0byBleHRlbmQgYEhlYWRlcnNgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXRhaWxzLmhlYWRlcnMuaGFzKFwidXNlci1hZ2VudFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvdCBkZXRlY3Rpb24gcmVxdWlyZXMgdXNlci1hZ2VudCBoZWFkZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRlbXB0cyB0byBjYWxsIHRoZSBib3QgZGV0ZWN0aW9uIG9uIHRoZSBoZWFkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiYWxsb3dcIiwgYWxsb3cpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiZGVueVwiLCBkZW55KSk7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmdlcnByaW50IH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgW2NhY2hlZCwgdHRsXSA9IGF3YWl0IGNvbnRleHQuY2FjaGUuZ2V0KHJ1bGVJZCwgZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGNhY2hlZC5yZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplLmRldGVjdEJvdChjb250ZXh0LCB0b0FuYWx5emVSZXF1ZXN0KHJlcXVlc3QpLCBjb25maWcpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBtb2RlID09PSBcIkxJVkVcIiA/IFwiUlVOXCIgOiBcIkRSWV9SVU5cIjtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBib3QgYW5kIG9mIGEgdHlwZSB0aGF0IHdlIHdhbnQgdG8gYmxvY2ssIHRoZW4gYmxvY2shXG4gICAgICAgICAgICBpZiAocmVzdWx0LmRlbmllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiA2MCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiREVOWVwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRCb3RSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZDogcmVzdWx0LmFsbG93ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5pZWQ6IHJlc3VsdC5kZW5pZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogcmVzdWx0LnZlcmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bvb2ZlZDogcmVzdWx0LnNwb29mZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRCb3RSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZDogcmVzdWx0LmFsbG93ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5pZWQ6IHJlc3VsdC5kZW5pZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogcmVzdWx0LnZlcmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bvb2ZlZDogcmVzdWx0LnNwb29mZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IFNoaWVsZCBXQUYgcnVsZS5cbiAqXG4gKiBBcHBseWluZyB0aGlzIHJ1bGUgcHJvdGVjdHMgeW91ciBhcHBsaWNhdGlvbiBhZ2FpbnN0IGNvbW1vbiBhdHRhY2tzLFxuICogaW5jbHVkaW5nIHRoZSBPV0FTUCBUb3AgMTAuXG4gKlxuICogVGhlIEFyY2pldCBTaGllbGQgV0FGIGFuYWx5emVzIGV2ZXJ5IHJlcXVlc3QgdG8geW91ciBhcHBsaWNhdGlvbiB0byBkZXRlY3RcbiAqIHN1c3BpY2lvdXMgYWN0aXZpdHkuXG4gKiBPbmNlIGEgY2VydGFpbiBzdXNwaWNpb24gdGhyZXNob2xkIGlzIHJlYWNoZWQsXG4gKiBzdWJzZXF1ZW50IHJlcXVlc3RzIGZyb20gdGhhdCBjbGllbnQgYXJlIGJsb2NrZWQgZm9yIGEgcGVyaW9kIG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgdGhlIFNoaWVsZCBydWxlLlxuICogQHJldHVybnNcbiAqICAgU2hpZWxkIHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgIGZpZWxkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIHNoaWVsZCh7IG1vZGU6IFwiTElWRVwiIH0pO1xuICogICBgYGBcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtzaGllbGQoeyBtb2RlOiBcIkxJVkVcIiB9KV0sXG4gKiAgIH0pO1xuICogICBgYGBcbiAqXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zaGllbGQvY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NoaWVsZC9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gc2hpZWxkKG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZVNoaWVsZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiU0hJRUxEXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5TaGllbGQsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZhbGlkYXRlKCkgeyB9LFxuICAgICAgICBhc3luYyBwcm90ZWN0KGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oIzE5ODkpOiBQcmVmZXIgY2hhcmFjdGVyaXN0aWNzIGRlZmluZWQgb24gcnVsZSBvbmNlIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29uc3QgbG9jYWxDaGFyYWN0ZXJpc3RpY3MgPSBjb250ZXh0LmNoYXJhY3RlcmlzdGljcztcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IGF3YWl0IGhhc2hlci5oYXNoKGhhc2hlci5zdHJpbmcoXCJ0eXBlXCIsIHR5cGUpLCBoYXNoZXIudWludDMyKFwidmVyc2lvblwiLCB2ZXJzaW9uKSwgaGFzaGVyLnN0cmluZyhcIm1vZGVcIiwgbW9kZSksIGhhc2hlci5zdHJpbmdTbGljZU9yZGVyZWQoXCJjaGFyYWN0ZXJpc3RpY3NcIiwgbG9jYWxDaGFyYWN0ZXJpc3RpY3MpKTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5emVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogbG9jYWxDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICAgICAgbG9nOiBjb250ZXh0LmxvZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGF3YWl0IGFuYWx5emUuZ2VuZXJhdGVGaW5nZXJwcmludChhbmFseXplQ29udGV4dCwgdG9BbmFseXplUmVxdWVzdChkZXRhaWxzKSk7XG4gICAgICAgICAgICBjb25zdCBbY2FjaGVkLCB0dGxdID0gYXdhaXQgY29udGV4dC5jYWNoZS5nZXQocnVsZUlkLCBmaW5nZXJwcmludCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJDQUNIRURcIixcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogY2FjaGVkLmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogY2FjaGVkLnJlYXNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJOT1RfUlVOXCIsXG4gICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFNoaWVsZFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIHNoaWVsZFRyaWdnZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBzaWdudXAgZm9ybSBwcm90ZWN0aW9uIHJ1bGUuXG4gKlxuICogQXBwbHlpbmcgdGhpcyBydWxlIGNvbWJpbmVzIHJhdGUgbGltaXRpbmcsIGJvdCBwcm90ZWN0aW9uLCBhbmQgZW1haWxcbiAqIHZhbGlkYXRpb24gdG8gcHJvdGVjdCB5b3VyIHNpZ251cCBmb3JtcyBmcm9tIGFidXNlLlxuICogVXNpbmcgdGhpcyBydWxlIHdpbGwgY29uZmlndXJlIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogLSBSYXRlIGxpbWl0aW5nIC0gc2lnbnVwIGZvcm1zIGFyZSBhIGNvbW1vbiB0YXJnZXQgZm9yIGJvdHMuIEFyY2pldOKAmXMgcmF0ZVxuICogICBsaW1pdGluZyBoZWxwcyB0byBwcmV2ZW50IGJvdHMgYW5kIG90aGVyIGF1dG9tYXRlZCBvciBtYWxpY2lvdXMgY2xpZW50c1xuICogICBmcm9tIHN1Ym1pdHRpbmcgeW91ciBzaWdudXAgZm9ybSB0b28gbWFueSB0aW1lcyBpbiBhIHNob3J0IHBlcmlvZCBvZiB0aW1lLlxuICogLSBCb3QgcHJvdGVjdGlvbiAtIHNpZ251cCBmb3JtcyBhcmUgdXN1YWxseSBleGNsdXNpdmVseSB1c2VkIGJ5IGh1bWFucywgd2hpY2hcbiAqICAgbWVhbnMgdGhhdCBhbnkgYXV0b21hdGVkIHN1Ym1pc3Npb25zIHRvIHRoZSBmb3JtIGFyZSBsaWtlbHkgdG8gYmVcbiAqICAgZnJhdWR1bGVudC5cbiAqIC0gRW1haWwgdmFsaWRhdGlvbiAtIGVtYWlsIGFkZHJlc3NlcyBzaG91bGQgYmUgdmFsaWRhdGVkIHRvIGVuc3VyZSB0aGUgc2lnbnVwXG4gKiAgIGlzIGNvbWluZyBmcm9tIGEgbGVnaXRpbWF0ZSB1c2VyIHdpdGggYSByZWFsIGVtYWlsIGFkZHJlc3MgdGhhdCBjYW5cbiAqICAgYWN0dWFsbHkgcmVjZWl2ZSBtZXNzYWdlcy5cbiAqXG4gKiBAdGVtcGxhdGUgQ2hhcmFjdGVyaXN0aWNzXG4gKiAgIENoYXJhY3RlcmlzdGljcyB0byB0cmFjayBhIHVzZXIgYnkuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciB0aGUgc2lnbnVwIGZvcm0gcHJvdGVjdGlvbiBydWxlLlxuICogQHJldHVybnNcbiAqICAgU2lnbnVwIGZvcm0gcHJvdGVjdGlvbiBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYCBmaWVsZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBPdXIgcmVjb21tZW5kZWQgY29uZmlndXJhdGlvbiBmb3IgbW9zdCBzaWdudXAgZm9ybXMgaXM6XG4gKlxuICogICAtIEJsb2NrIGVtYWlsIGFkZHJlc3NlcyB3aXRoIGludmFsaWQgc3ludGF4LCB0aGF0IGFyZSBmcm9tIGRpc3Bvc2FibGUgZW1haWwgcHJvdmlkZXJzLFxuICogICAgIG9yIGRvIG5vdCBoYXZlIHZhbGlkIE1YIHJlY29yZHMgY29uZmlndXJlZC5cbiAqICAgLSBCbG9jayBhbGwgYm90cy5cbiAqICAgLSBBcHBseSBhIHJhdGUgbGltaXQgb2YgNSBzdWJtaXNzaW9ucyBwZXIgMTAgbWludXRlcyBmcm9tIGEgc2luZ2xlIElQXG4gKiAgICAgYWRkcmVzcy5cbiAqXG4gKiAgIGBgYHRzXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgcHJvdGVjdFNpZ251cCh7XG4gKiAgICAgICAgZW1haWw6IHtcbiAqICAgICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgICAgYmxvY2s6IFtcIkRJU1BPU0FCTEVcIiwgXCJJTlZBTElEXCIsIFwiTk9fTVhfUkVDT1JEU1wiXSxcbiAqICAgICAgICB9LFxuICogICAgICAgIGJvdHM6IHtcbiAqICAgICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgICAgYWxsb3c6IFtdLCAvLyBibG9jayBhbGwgZGV0ZWN0ZWQgYm90c1xuICogICAgICAgIH0sXG4gKiAgICAgICAgcmF0ZUxpbWl0OiB7XG4gKiAgICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgIGludGVydmFsOiBcIjEwbVwiLFxuICogICAgICAgICAgbWF4OiA1LFxuICogICAgICAgIH0sXG4gKiAgICAgIH0pLFxuICogICAgXSxcbiAqICAgfSk7XG4gKiAgIGBgYFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NpZ251cC1wcm90ZWN0aW9uL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zaWdudXAtcHJvdGVjdGlvbi9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gcHJvdGVjdFNpZ251cChvcHRpb25zKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uc2xpZGluZ1dpbmRvdyhvcHRpb25zLnJhdGVMaW1pdCksXG4gICAgICAgIC4uLmRldGVjdEJvdChvcHRpb25zLmJvdHMpLFxuICAgICAgICAuLi52YWxpZGF0ZUVtYWlsKG9wdGlvbnMuZW1haWwpLFxuICAgIF07XG59XG4vKipcbiAqIEFyY2pldCBmaWx0ZXIgcnVsZS5cbiAqXG4gKiBBcHBseWluZyB0aGlzIHJ1bGUgbGV0cyB5b3UgYmxvY2sgcmVxdWVzdHMgdXNpbmcgV2lyZXNoYXJrLWxpa2UgZGlzcGxheVxuICogZmlsdGVyIGV4cHJlc3Npb25zIG92ZXIgSFRUUCBoZWFkZXJzLCBJUCBhZGRyZXNzZXMsIGFuZCBvdGhlciByZXF1ZXN0XG4gKiBmaWVsZHMuXG4gKiBZb3UgY2FuIHF1aWNrbHkgZW5mb3JjZSBydWxlcyBsaWtlIGFsbG93L2RlbnkgYnkgY291bnRyeSwgbmV0d29yaywgb3JcbiAqIGB1c2VyLWFnZW50YCBwYXR0ZXJuLlxuICpcbiAqIFNlZSB0aGUgW3JlZmVyZW5jZSBndWlkZV0oaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vZmlsdGVycy9yZWZlcmVuY2UpIGZvclxuICogbW9yZSBpbmZvIG9uIHRoZSBleHByZXNzaW9uIGxhbmd1YWdlIGZpZWxkcywgZnVuY3Rpb25zLCBhbmQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gKHJlcXVpcmVkKS5cbiAqIEByZXR1cm5zXG4gKiAgIEZpbHRlciBydWxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIEluIHRoaXMgZXhhbXBsZSwgdGhlIGV4cHJlc3Npb24gbWF0Y2hlcyBub24tVlBOIEdFVCByZXF1ZXN0cyBmcm9tIHRoZSBVUy5cbiAqICAgUmVxdWVzdHMgbWF0Y2hpbmcgdGhlIGV4cHJlc3Npb24gYXJlIGFsbG93ZWQsIGFsbCBvdGhlcnMgYXJlIGRlbmllZC5cbiAqXG4gKiAgIGBgYHRzXG4gKiAgIGZpbHRlcih7XG4gKiAgICAgYWxsb3c6IFtcbiAqICAgICAgICdodHRwLnJlcXVlc3QubWV0aG9kIGVxIFwiR0VUXCIgYW5kIGlwLnNyYy5jb3VudHJ5IGVxIFwiVVNcIiBhbmQgbm90IGlwLnNyYy52cG4nLFxuICogICAgIF0sXG4gKiAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgIH0pXG4gKiAgIGBgYFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2ZpbHRlcnMvcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVGaWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBhbGxvdyA9IG9wdGlvbnMuYWxsb3cgPz8gW107XG4gICAgY29uc3QgZGVueSA9IG9wdGlvbnMuZGVueSA/PyBbXTtcbiAgICBpZiAoYWxsb3cubGVuZ3RoID4gMCAmJiBkZW55Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGZpbHRlcmAgb3B0aW9ucyBlcnJvcjogZXhwcmVzc2lvbnMgbXVzdCBiZSBwYXNzZWQgaW4gZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgIGluc3RlYWQgb2YgYm90aFwiKTtcbiAgICB9XG4gICAgaWYgKGFsbG93Lmxlbmd0aCA9PT0gMCAmJiBkZW55Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZmlsdGVyYCBvcHRpb25zIGVycm9yOiBvbmUgb3IgbW9yZSBleHByZXNzaW9ucyBtdXN0IGJlIHBhc3NlZCBpbiBgYWxsb3dgIG9yIGBkZW55YFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBtb2RlID09PSBcIkxJVkVcIiA/IFwiUlVOXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCB0eXBlID0gXCJGSUxURVJcIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBydWxlSWRQcm9taXNlID0gaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImFsbG93XCIsIFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBoYXNoZXJgIG11c3Qgc3VwcG9ydCByZWFkb25seSB2YWx1ZXMuXG4gICAgYWxsb3cpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiZGVueVwiLCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgaGFzaGVyYCBtdXN0IHN1cHBvcnQgcmVhZG9ubHkgdmFsdWVzLlxuICAgIGRlbnkpKTtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBhbGxvdyxcbiAgICAgICAgZGVueSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LkZpbHRlcixcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBydWxlSWRQcm9taXNlO1xuICAgICAgICAgICAgY29uc3QgW2NhY2hlZCwgdHRsXSA9IGF3YWl0IGNvbnRleHQuY2FjaGUuZ2V0KHJ1bGVJZCwgY29udGV4dC5maW5nZXJwcmludCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogY2FjaGVkLmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50OiBjb250ZXh0LmZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGNhY2hlZC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RfID0gdG9BbmFseXplUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxldCBydWxlUmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplLm1hdGNoRmlsdGVycyhjb250ZXh0LCByZXF1ZXN0XywgYWxsb3cubGVuZ3RoID4gMCA/IGFsbG93IDogZGVueSwgYWxsb3cubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICAgICAgcnVsZVJlc3VsdCA9IG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogcmVzdWx0LmFsbG93ZWQgPyBcIkFMTE9XXCIgOiBcIkRFTllcIixcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQ6IGNvbnRleHQuZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEZpbHRlclJlYXNvbihyZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB0dGw6IHJlc3VsdC5hbGxvd2VkID8gMCA6IDYwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcnVsZVJlc3VsdCA9IG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludDogY29udGV4dC5maW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZVJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsaWRhdGUoKSB7IH0sXG4gICAgICAgIHZlcnNpb24sXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQXJjamV0IGluc3RhbmNlLlxuICpcbiAqIEB0ZW1wbGF0ZSBSdWxlc1xuICogICBMaXN0IG9mIHJ1bGVzLlxuICogQHRlbXBsYXRlIENoYXJhY3RlcmlzdGljc1xuICogICBDaGFyYWN0ZXJpc3RpY3MgdG8gdHJhY2sgYSB1c2VyIGJ5LlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zXG4gKiAgIEFyY2pldCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gYXJjamV0KG9wdGlvbnMpIHtcbiAgICAvLyBXZSBkZXN0cnVjdHVyZSBoZXJlIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBuZWF0IHdoZW4gdmlld2VkIGJ5IGNvbnN1bWVyc1xuICAgIGNvbnN0IHsga2V5LCBydWxlcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBydCA9IHJ1bnRpbWUoKTtcbiAgICAvLyBUT0RPOiBTZXBhcmF0ZSB0aGUgQXJjamV0T3B0aW9ucyBmcm9tIHRoZSBTREsgT3B0aW9uc1xuICAgIC8vIEl0IGlzIGN1cnJlbnRseSBvcHRpb25hbCBpbiB0aGUgb3B0aW9ucyBzbyB1c2VycyBjYW4gb3ZlcnJpZGUgaXQgdmlhIGFuIFNES1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9nIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBsb2cgPSBvcHRpb25zLmxvZztcbiAgICBjb25zdCBwZXJmID0gbmV3IFBlcmZvcm1hbmNlKGxvZyk7XG4gICAgLy8gVE9ETygjMjA3KTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBjYW4gZGVmYXVsdCB0aGUgdHJhbnNwb3J0IHNvIGNsaWVudCBpcyBub3QgcmVxdWlyZWRcbiAgICAvLyBJdCBpcyBjdXJyZW50bHkgb3B0aW9uYWwgaW4gdGhlIG9wdGlvbnMgc28gdGhlIE5leHQgU0RLIGNhbiBvdmVycmlkZSBpdCBmb3IgdGhlIHVzZXJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2xpZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG4gICAgLy8gQSBsb2NhbCBjYWNoZSBvZiBibG9jayBkZWNpc2lvbnMuIE1pZ2h0IGJlIGVtcGhlbWVyYWwgcGVyIHJlcXVlc3QsXG4gICAgLy8gZGVwZW5kaW5nIG9uIHRoZSB3YXkgdGhlIHJ1bnRpbWUgd29ya3MsIGJ1dCBpdCdzIHdvcnRoIGEgdHJ5LlxuICAgIC8vIFRPRE8oIzEzMik6IFN1cHBvcnQgY29uZmlndXJhYmxlIGNhY2hpbmdcbiAgICBjb25zdCBjYWNoZSA9IG5ldyBNZW1vcnlDYWNoZSgpO1xuICAgIGNvbnN0IHJvb3RSdWxlcyA9IHJ1bGVzXG4gICAgICAgIC5mbGF0KDEpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvdGVjdChydWxlcywgY3R4LCByZXF1ZXN0KSB7XG4gICAgICAgIC8vIFRoaXMgZ29lcyBhZ2FpbnN0IHRoZSB0eXBlIGRlZmluaXRpb24gYWJvdmUsIGJ1dCB1c2VycyBtaWdodCBjYWxsXG4gICAgICAgIC8vIGBwcm90ZWN0KClgIHdpdGggbm8gdmFsdWUgYW5kIHdlIGRvbid0IHdhbnQgdG8gY3Jhc2hcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGV0YWlscyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgaXA6IHJlcXVlc3QuaXAsXG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgcHJvdG9jb2w6IHJlcXVlc3QucHJvdG9jb2wsXG4gICAgICAgICAgICBob3N0OiByZXF1ZXN0Lmhvc3QsXG4gICAgICAgICAgICBwYXRoOiByZXF1ZXN0LnBhdGgsXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgQXJjamV0SGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLFxuICAgICAgICAgICAgY29va2llczogcmVxdWVzdC5jb29raWVzLFxuICAgICAgICAgICAgcXVlcnk6IHJlcXVlc3QucXVlcnksXG4gICAgICAgICAgICBleHRyYTogZXh0cmFQcm9wcyhyZXF1ZXN0KSxcbiAgICAgICAgICAgIGVtYWlsOiB0eXBlb2YgcmVxdWVzdC5lbWFpbCA9PT0gXCJzdHJpbmdcIiA/IHJlcXVlc3QuZW1haWwgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBvcHRpb25zLmNoYXJhY3RlcmlzdGljc1xuICAgICAgICAgICAgPyBbLi4ub3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NdXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCB3YWl0VW50aWwgPSBsb29rdXBXYWl0VW50aWwoKTtcbiAgICAgICAgY29uc3QgYmFzZUNvbnRleHQgPSB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBsb2csXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICB3YWl0VW50aWwsXG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBmaW5nZXJwcmludCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGxvZ0ZpbmdlcnByaW50UGVyZiA9IHBlcmYubWVhc3VyZShcImZpbmdlcnByaW50XCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluZ2VycHJpbnQgPSBhd2FpdCBhbmFseXplLmdlbmVyYXRlRmluZ2VycHJpbnQoYmFzZUNvbnRleHQsIHRvQW5hbHl6ZVJlcXVlc3QoZGV0YWlscykpO1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiZmluZ2VycHJpbnQgKCVzKTogJXNcIiwgcnQsIGZpbmdlcnByaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcih7IGVycm9yOiBlcnJvck1lc3NhZ2UoZXJyb3IpIH0sIFwiRmFpbGVkIHRvIGJ1aWxkIGZpbmdlcnByaW50LiBQbGVhc2UgdmVyaWZ5IHlvdXIgQ2hhcmFjdGVyaXN0aWNzLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gbmV3IEFyY2pldEVycm9yRGVjaXNpb24oe1xuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFcnJvclJlYXNvbihgRmFpbGVkIHRvIGJ1aWxkIGZpbmdlcnByaW50IC0gJHtlcnJvck1lc3NhZ2UoZXJyb3IpfWApLFxuICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdHMgYmVjYXVzZSB3ZSBjb3VsZG4ndCBjcmVhdGUgYSBmaW5nZXJwcmludFxuICAgICAgICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBzZW5kaW5nIHRoaXMgdG8gUmVwb3J0IHdoZW4gd2UgaGF2ZSBhbiBpbmZhbGxpYmxlIGZpbmdlcnByaW50XG4gICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBsb2dGaW5nZXJwcmludFBlcmYoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAuLi5iYXNlQ29udGV4dCxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBydW50aW1lOiBydCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkNhbGxpbmcgYHByb3RlY3QoKWAgd2l0aCBubyBydWxlcyBpcyBkZXByZWNhdGVkLiBEaWQgeW91IG1lYW4gdG8gY29uZmlndXJlIHRoZSBTaGllbGQgcnVsZT9cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGVzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsdXJlIHJ1bm5pbmcgcnVsZXMuIE9ubHkgMTAgcnVsZXMgbWF5IGJlIHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXRFcnJvckRlY2lzaW9uKHtcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oXCJPbmx5IDEwIHJ1bGVzIG1heSBiZSBzcGVjaWZpZWRcIiksXG4gICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0cyBiZWNhdXNlIHRoZSBzb3J0ZWQgcnVsZXMgd2VyZSB0b28gbG9uZyBhbmQgd2UgZG9uJ3Qgd2FudFxuICAgICAgICAgICAgICAgIC8vIHRvIGluc3RhbnRpYXRlIGEgdG9uIG9mIE5PVF9SVU4gcmVzdWx0c1xuICAgICAgICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbGllbnQucmVwb3J0KGNvbnRleHQsIGRldGFpbHMsIGRlY2lzaW9uLCBcbiAgICAgICAgICAgIC8vIE5vIHJ1bGVzIGJlY2F1c2Ugd2UndmUgZGV0ZXJtaW5lZCB0aGV5IHdlcmUgdG9vIGxvbmcgYW5kIHdlIGRvbid0XG4gICAgICAgICAgICAvLyB3YW50IHRvIHRyeSB0byBzZW5kIHRoZW0gdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgW10pO1xuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcnVsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGwgcnVsZXMgdG8gTk9UX1JVTi9BTExPVyBiZWZvcmUgZG9pbmcgYW55dGhpbmdcbiAgICAgICAgICAgIHJlc3VsdHNbaWR4XSA9IG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKCM0MDMwKTogRmlndXJlIG91dCBpZiB3ZSBjYW4gZ2V0IGVhY2ggUnVsZSBJRCBiZWZvcmUgdGhleSBhcmUgcnVuXG4gICAgICAgICAgICAgICAgcnVsZUlkOiBcIlwiLFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJOT1RfUlVOXCIsXG4gICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFJlYXNvbigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgdG9wLWxldmVsIGNoYXJhY3RlcmlzdGljcyB0byBhbGwgUmF0ZSBMaW1pdCBydWxlcyB0aGF0IGRvbid0IGFscmVhZHkgaGF2ZVxuICAgICAgICAgICAgLy8gdGhlaXIgb3duIHNldCBvZiBjaGFyYWN0ZXJpc3RpY3MuXG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGVfcnVsZSA9IHJ1bGVzW2lkeF07XG4gICAgICAgICAgICBpZiAoaXNSYXRlTGltaXRSdWxlKGNhbmRpZGF0ZV9ydWxlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlX3J1bGUuY2hhcmFjdGVyaXN0aWNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZV9ydWxlLmNoYXJhY3RlcmlzdGljcyA9IGNoYXJhY3RlcmlzdGljcztcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaWR4XSA9IGNhbmRpZGF0ZV9ydWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2dMb2NhbFBlcmYgPSBwZXJmLm1lYXN1cmUoXCJsb2NhbFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkeCwgcnVsZV0gb2YgcnVsZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZS1hc3NpZ25tZW50IGlzIGEgd29ya2Fyb3VuZCB0byBhIFR5cGVTY3JpcHQgZXJyb3Igd2l0aFxuICAgICAgICAgICAgICAgIC8vIGFzc2VydGlvbnMgd2hlcmUgdGhlIG5hbWUgd2FzIGludHJvZHVjZWQgdmlhIGEgZGVzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFJ1bGUgPSBydWxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ1J1bGVQZXJmID0gcGVyZi5tZWFzdXJlKHJ1bGUudHlwZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFJ1bGUudmFsaWRhdGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicnVsZSBtdXN0IGhhdmUgYSBgdmFsaWRhdGVgIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUnVsZS52YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFJ1bGUucHJvdGVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJydWxlIG11c3QgaGF2ZSBhIGBwcm90ZWN0YCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2lkeF0gPSBhd2FpdCBsb2NhbFJ1bGUucHJvdGVjdChjb250ZXh0LCBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBydWxlIGRpZG4ndCByZXR1cm4gYSBydWxlIHJlc3VsdCwgd2UgbmVlZCB0byBzdHViIGl0IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyYXNoaW5nLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBhIHVzZXIgd3JpdGVzIGEgY3VzdG9tIGxvY2FsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJ1bGUgaW5jb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0c1tpZHhdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2lkeF0gPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETygjNDAzMCk6IElmIHdlIGNhbiBnZXQgdGhlIFJ1bGUgSUQgYmVmb3JlIHJ1bm5pbmcgcnVsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUlkOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJSVU5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oXCJydWxlIHJlc3VsdCBtaXNzaW5nXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiByZXN1bHRzW2lkeF0ucnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBkZXRhaWxzLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW50aW1lOiBydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogcmVzdWx0c1tpZHhdLnR0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IHJlc3VsdHNbaWR4XS5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZXN1bHRzW2lkeF0ucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICB9LCBcIkxvY2FsIHJ1bGUgcmVzdWx0OlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsdXJlIHJ1bm5pbmcgcnVsZTogJXMgZHVlIHRvICVzXCIsIHJ1bGUudHlwZSwgZXJyb3JNZXNzYWdlKGVycikpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2lkeF0gPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKCM0MDMwKTogRmlndXJlIG91dCBpZiB3ZSBjYW4gZ2V0IGEgUnVsZSBJRCBpbiB0aGlzIGVycm9yIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVJZDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFcnJvclJlYXNvbihlcnIpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ1J1bGVQZXJmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmlzRGVuaWVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJ1bGUgaXMgbm90IGEgRFJZX1JVTiwgd2Ugd2FudCB0byBjYWNoZSBub24temVybyBUVEwgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIGEgREVOWSBkZWNpc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSAhPT0gXCJEUllfUlVOXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gbmV3IEFyY2pldERlbnlEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiByZXN1bHQudHRsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0LnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGEgREVOWSBkZWNpc2lvbiBpcyByZXBvcnRlZCB0byBhdm9pZCBjcmVhdGluZyAyIGVudHJpZXMgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHJlcXVlc3QuIFVwb24gQUxMT1csIHRoZSBgZGVjaWRlYCBjYWxsIHdpbGwgY3JlYXRlIGFuIGVudHJ5IGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQucmVwb3J0KGNvbnRleHQsIGRldGFpbHMsIGRlY2lzaW9uLCBydWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR0bCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludDogcmVzdWx0LmZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiByZXN1bHQuY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZXN1bHQucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFwiQ2FjaGluZyBkZWNpc2lvbiBmb3IgJWQgc2Vjb25kc1wiLCBkZWNpc2lvbi50dGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChyZXN1bHQucnVsZUlkLCByZXN1bHQuZmluZ2VycHJpbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogcmVzdWx0LmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0LnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCByZXN1bHQudHRsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgRHJ5IHJ1biBtb2RlIGlzIGVuYWJsZWQgZm9yIFwiJXNcIiBydWxlLiBPdmVycmlkaW5nIGRlY2lzaW9uLiBEZWNpc2lvbiB3YXM6IERFTllgLCBydWxlLnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGxvZ0xvY2FsUGVyZigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdpdGggbm8gY2FjaGVkIHZhbHVlcywgd2UgdGFrZSBhIGRlY2lzaW9uIHJlbW90ZWx5LiBXZSB1c2UgYSB0aW1lb3V0IHRvXG4gICAgICAgIC8vIGZhaWwgb3Blbi5cbiAgICAgICAgY29uc3QgbG9nUmVtb3RlUGVyZiA9IHBlcmYubWVhc3VyZShcInJlbW90ZVwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0RlZGljZUFwaVBlcmYgPSBwZXJmLm1lYXN1cmUoXCJkZWNpZGVBcGlcIik7XG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IGF3YWl0IGNsaWVudFxuICAgICAgICAgICAgICAgIC5kZWNpZGUoY29udGV4dCwgZGV0YWlscywgcnVsZXMpXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ0RlZGljZUFwaVBlcmYoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRlY2lzaW9uIGlzIHRvIGJsb2NrIGFuZCB3ZSBoYXZlIGEgbm9uLXplcm8gVFRMLCB3ZSBjYWNoZSB0aGVcbiAgICAgICAgICAgIC8vIGJsb2NrIGxvY2FsbHlcbiAgICAgICAgICAgIGlmIChkZWNpc2lvbi5pc0RlbmllZCgpICYmIGRlY2lzaW9uLnR0bCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJkZWNpZGU6IENhY2hpbmcgYmxvY2sgbG9jYWxseSBmb3IgJWQgc2Vjb25kc1wiLCBkZWNpc2lvbi50dGwpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIGRlY2lzaW9uLnJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgYWxsIERFTlkgcmVzdWx0cyBmb3IgbG9jYWwgY2FjaGUgbG9va3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNvbmNsdXNpb24gPT09IFwiREVOWVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQocmVzdWx0LnJ1bGVJZCwgcmVzdWx0LmZpbmdlcnByaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogcmVzdWx0LmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZXN1bHQucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzdWx0LnR0bCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nLmluZm8oXCJFbmNvdW50ZXJlZCBwcm9ibGVtIGdldHRpbmcgcmVtb3RlIGRlY2lzaW9uOiAlc1wiLCBlcnJvck1lc3NhZ2UoZXJyKSk7XG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXRFcnJvckRlY2lzaW9uKHtcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oZXJyKSxcbiAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbGllbnQucmVwb3J0KGNvbnRleHQsIGRldGFpbHMsIGRlY2lzaW9uLCBydWxlcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBsb2dSZW1vdGVQZXJmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZlbHlcbiAgICBmdW5jdGlvbiB3aXRoUnVsZShiYXNlUnVsZXMsIHJ1bGUpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSBbLi4uYmFzZVJ1bGVzLCAuLi5ydWxlXS5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIHdpdGhSdWxlKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aFJ1bGUocnVsZXMsIHJ1bGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHByb3RlY3QoY3R4LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RlY3QocnVsZXMsIGN0eCwgcmVxdWVzdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQXVnbWVudCB0aGUgY2xpZW50IHdpdGggYW5vdGhlciBydWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VmdWwgZm9yIHZhcnlpbmcgcnVsZXMgYmFzZWQgb24gY3JpdGVyaWEgaW4geW91ciBoYW5kbGVyIHN1Y2ggYXNcbiAgICAgICAgICogZGlmZmVyZW50IHJhdGUgbGltaXQgZm9yIGxvZ2dlZCBpbiB1c2Vycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJ1bGVcbiAgICAgICAgICogICBSdWxlIHRvIGFkZCB0byBBcmNqZXQuXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqICAgQXJjamV0IGluc3RhbmNlIGF1Z21lbnRlZCB3aXRoIHRoZSBnaXZlbiBydWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgd2l0aFJ1bGUocnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhSdWxlKHJvb3RSdWxlcywgcnVsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIGEgZGVjaXNpb24gYWJvdXQgaG93IHRvIGhhbmRsZSBhIHJlcXVlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBhbmFseXplIHRoZSByZXF1ZXN0IGxvY2FsbHkgd2hlcmUgcG9zc2libGUgYW5kIG90aGVyd2lzZSBjYWxsXG4gICAgICAgICAqIHRoZSBBcmNqZXQgZGVjaXNpb24gQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY3R4XG4gICAgICAgICAqICAgQWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGlzIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICAgICAqICAgRGV0YWlscyBhYm91dCB0aGUge0BsaW5rY29kZSBBcmNqZXRSZXF1ZXN0fSB0aGF0IEFyY2pldCBuZWVkcyB0byBtYWtlIGFcbiAgICAgICAgICogICBkZWNpc2lvbi5cbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICogICBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4ge0BsaW5rY29kZSBBcmNqZXREZWNpc2lvbn0gaW5kaWNhdGluZ1xuICAgICAgICAgKiAgIEFyY2pldOKAmXMgZGVjaXNpb24gYWJvdXQgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBwcm90ZWN0KGN0eCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RlY3Qocm9vdFJ1bGVzLCBjdHgsIHJlcXVlc3QpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBhcmNqZXQgYXMgZGVmYXVsdCwgZGV0ZWN0Qm90LCBmaWx0ZXIsIGZpeGVkV2luZG93LCBwcm90ZWN0U2lnbnVwLCBzZW5zaXRpdmVJbmZvLCBzaGllbGQsIHNsaWRpbmdXaW5kb3csIHRva2VuQnVja2V0LCB2YWxpZGF0ZUVtYWlsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/arcjet/index.js\n");

/***/ })

};
;